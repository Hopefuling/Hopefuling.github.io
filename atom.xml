<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>I&#39;m Hopefuling</title>
  
  
  <link href="https://hopefuling.github.io/atom.xml" rel="self"/>
  
  <link href="https://hopefuling.github.io/"/>
  <updated>2023-09-19T10:51:00.781Z</updated>
  <id>https://hopefuling.github.io/</id>
  
  <author>
    <name>Hopefuling</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>xv6实验</title>
    <link href="https://hopefuling.github.io/2023/09/19/xv6_lab/"/>
    <id>https://hopefuling.github.io/2023/09/19/xv6_lab/</id>
    <published>2023-09-19T10:41:03.000Z</published>
    <updated>2023-09-19T10:51:00.781Z</updated>
    
    <content type="html"><![CDATA[<h1 id="xv6实验"><a href="#xv6实验" class="headerlink" title="xv6实验"></a>xv6实验</h1><p><strong>author</strong>:  Hopefuling</p><hr><p>[TOC]</p><hr><p>参考指导手册：</p><p>xv6中文指导手册：<a href="http://xv6.dgs.zone/">http://xv6.dgs.zone/</a></p><hr><h2 id="Lab01"><a href="#Lab01" class="headerlink" title="Lab01"></a>Lab01</h2><h3 id="Lab01-0-环境配置"><a href="#Lab01-0-环境配置" class="headerlink" title="Lab01-0:环境配置"></a>Lab01-0:环境配置</h3><p>&#x3D;&#x3D;date: 2023&#x2F;9&#x2F;12&#x3D;&#x3D;</p><p>实验环境：windows11+ vmware+ Ubuntu 22.04</p><p>按官方文档配置：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&#x2F;&#x2F;安装之前先换源，再软件更新sudo apt update sudo apt install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu libglib2.0-dev libpixman-1-dev gcc-riscv64-unknown-elf&#x2F;&#x2F;查看安装是否成功：riscv64-unknown-elf-gcc   --versionqemu-system-riscv64 --versiongit clone git:&#x2F;&#x2F;g.csail.mit.edu&#x2F;xv6-labs-2022cd xv6-labs-2022git checkout util     &#x2F;&#x2F;切换到lab分支util</code></pre><p>进入&#x2F;user目录下可以看到xv6指令集的源码：</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309121445960.png" alt="image-20230912144518851"></p><p>以及kernel下的内核文件：</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309121446664.png" alt="image-20230912144611597"></p><h3 id="Lab01-1-sleep-c"><a href="#Lab01-1-sleep-c" class="headerlink" title="Lab01-1:sleep.c"></a>Lab01-1:sleep.c</h3><p>实验地址：<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/util.html">https://pdos.csail.mit.edu/6.S081/2020/labs/util.html</a> </p><p>代码参考：<a href="https://github.com/whileskies/xv6-labs-2020/blob/main/doc/Lab1-Xv6%20and%20Unix%20utilities.md">https://github.com/whileskies/xv6-labs-2020/blob/main/doc/Lab1-Xv6%20and%20Unix%20utilities.md</a></p><p>博客参考：<a href="https://ttzytt.com/2022/07/xv6_lab1_record/">https://ttzytt.com/2022/07/xv6_lab1_record/</a>   必看</p><p>检测命令参数数目，之后直接调用系统的sleep函数即可。我采用的是vim编辑器：</p><p>vim &#x2F;user&#x2F; sleep.c       进入i编辑模式：</p><p>输入以下代码：（在上面的网站有）</p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309121125824.png" align="left"  ><p>:wq 保存退出</p><p> 执行sleep命令：</p><p>先切换到xv6目录，vim 编辑Makefile，在191行处添加$U&#x2F;_sleep\，:wq保存退出：</p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309121125826.png" align="left"><p>（注：显示行号命令   :set nu ）</p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309121125907.png" align="left"><p> 完成后切换回根目录，make qemu执行启动qemu，此时执行ls命令可以看到命令集已经添加了sleep指令，输入sleep 5，执行sleep指令，执行结果是输入光标短暂停止之后，继续闪烁。</p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309121125283.png" align="left"><p> 加大sleep时间可以看的更明显。比如 sleep 20</p><h3 id="Lab01-2-pingpong-c"><a href="#Lab01-2-pingpong-c" class="headerlink" title="Lab01-2:pingpong.c"></a>Lab01-2:pingpong.c</h3><p>题目要求的顺序：</p><ul><li>父进程向子进程发送 1 字节</li><li>子进程输出 “<pid>: received ping”</li><li>子进程向父进程发送 1 字节</li><li>父进程输出     “<pid>: received pong”</li></ul><p><strong>前置知识：</strong></p><p><strong>管道</strong>（pipe）是一种最基本的进程间通信机制。管道分为 <strong>读出端</strong> 和 <strong>写入端</strong> 两个部分，进程可以向写端写入数据，也可以从读端读出数据。通过pipe系统调用，内核会为用户进程创建管道，同时返回两个文件描述符，用以描述管道的读写端。</p><p>创建管道 ：<strong>int pipe(int fd[2]);</strong> </p><p>返回值：成功，返回0，否则返回-1。参数数组包含pipe使用的两个文件的描述符。</p><p>fd[0] 将是管道读取端的fd（文件描述符）<br>fd[1] 将是管道写入端的fd</p><p> &#x2F;&#x2F; 函数调用成功返回r&#x2F;w两个文件描述符。向管道文件读写数据其实是在读写内核缓冲区。</p><p>&#x2F;&#x2F; 必须在fork()中调用pipe()，否则子进程不会继承文件描述符。</p><p>示例：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">int p[2];int ret;&#x2F;&#x2F;返回值ret &#x3D; pipe(p); &#x2F;*正常创建后，p[1]为管道写入端，p[0]为管道读出端*&#x2F; </code></pre><p> 通过文件描述符，程序可以按读写文件的形式读写管道，例如：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">int write &#x3D; write(p[1], buffer, n); &#x2F;&#x2F;p[1]为管道写入端int read &#x3D; read(p[0], buffer, n);&#x2F;&#x2F;p[0]为管道读出端</code></pre><p>进程通常只持有某个管道的读出端或者写入端，因此使用的时候需要将另一端关闭。(单管道)</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;* 子进程读管道，父进程写管道 *&#x2F;int pid &#x3D; fork();if (pid &#x3D;&#x3D; 0) &#123;  &#x2F;* 子进程 *&#x2F; &#x2F;&#x2F;fork返回0为子进程    close(p[1]); &#x2F;&#x2F; 关闭写端    ...    read(...);    ...    close(p[0]); &#x2F;&#x2F; 读取完成，关闭读端&#125; else if (pid&gt;0) &#123;  &#x2F;* 父进程 *&#x2F; &#x2F;&#x2F;fork大于0为父进程    close(p[0]); &#x2F;&#x2F; 关闭读端    ...    write(...);    ...    close(p[1]); &#x2F;&#x2F; 写入完成，关闭写端&#125;</code></pre><hr><p>那么实验的大致步骤为：</p><ol><li><p>父进程调用pipe函数创建管道，得到两个文件描述符fd[0]、fd[1]指向管道的读端和写端。</p></li><li><p>父进程调用fork创建子进程，那么子进程也有两个文件描述符指向同一管道。</p></li><li><p>父进程关闭管道读端，子进程关闭管道写端。父进程可以向管道中写入数据，子进程将管道中的数据读出。由于管道是利用环形队列实现的，数据从写端流入管道，从读端流出，这样就实现了进程间通信。</p></li></ol><p>vim  user&#x2F;pingpong.c  </p><p>实验代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &quot;kernel&#x2F;types.h&quot;#include &quot;kernel&#x2F;stat.h&quot;#include &quot;user&#x2F;user.h&quot;int main(int argc, char *argv[])&#123;  int p1[2];   int p2[2];   if (pipe(p1) &lt; 0 || pipe(p2) &lt; 0) &#123;    fprintf(2, &quot;pingpong: pipe failed\n&quot;);    exit(1);  &#125;  int pid &#x3D; fork();  if (pid &lt; 0) &#123;&#x2F;&#x2F;创建子进程失败    fprintf(2, &quot;pingpong: fork child process failed\n&quot;);    exit(1);  &#125;  char buf[2] &#x3D; &#123;0&#125;;  if (pid &gt; 0) &#123; &#x2F;&#x2F; 父进程    &#x2F;&#x2F;管道读写是单工的，读写端不可以同时开启；避免子进程写端未关闭，干扰父进程的读操作    close(p1[0]);&#x2F;&#x2F;关闭父进程的管道读出端    close(p2[1]);&#x2F;&#x2F;关闭子进程的管道写入端    write(p1[1], &quot;a&quot;, 1);    read(p2[0], buf, sizeof buf); &#x2F;&#x2F;父进程读操作    fprintf(1, &quot;%d: received pong\n&quot;, getpid());    close(p1[1]);    close(p2[0]);  &#125; else &#123; &#x2F;&#x2F; pid&#x3D;0 子进程    close(p1[1]);&#x2F;&#x2F;关闭父进程的管道写入端    close(p2[0]);&#x2F;&#x2F;关闭子进程的管道读出端    read(p1[0], buf, sizeof buf); &#x2F;&#x2F;子进程写操作    fprintf(1, &quot;%d: received ping\n&quot;, getpid());    write(p2[1], &quot;b&quot;, 1);    close(p1[0]);    close(p2[1]);  &#125;  wait(0);  exit(0);&#125;</code></pre><p>添加MakeFile之后运行测试：</p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309121216493.png" alt="image-20230912121600407"  /><p>参考资源：</p><p><a href="https://xiaoxiami.gitbook.io/linux-server/duo-jin-cheng-bian-cheng/forkhan-shu">https://xiaoxiami.gitbook.io/linux-server/duo-jin-cheng-bian-cheng/forkhan-shu</a></p><p><a href="https://zhuanlan.zhihu.com/p/415609647">https://zhuanlan.zhihu.com/p/415609647</a></p><h3 id="Lab01-3-primes-c"><a href="#Lab01-3-primes-c" class="headerlink" title="Lab01-3: primes.c"></a>Lab01-3: primes.c</h3><p>该程序的逻辑是把 2-35 之间的质数筛选出来，并在终端进行输出。约定以下：</p><p>（1） 父进程 A 生成[2-35]之间的所有数字，包括 2 和 35；<br>（2） 向 A 的子进程 B 进行输出（通过管道）；<br>（3） B 对[2-35]进行筛选，打印出第一个质数 2；<br>（4） B 把剩下的数字（通过）通过管道传递给 B 的子进程 C；<br>（5） C 打印出第二个质数，也即 3；<br>（6） 重复（4）和（5）的过程，直到 2-35 之间的质数全部在终端输出。</p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309121452233.png" alt="image-20230912145203149" style="zoom:50%;" /><p>思路：</p><p>从主进程开始，不断新建子进程，每个子进程执行一次筛选，并将使用的基（base）认为是质数（这是正确的，请思考为什么），并返回，直到全部的数都被筛去或被返回。</p><p>各个进程之间的通讯将会使用到管道。</p><p>还需要注意两点：</p><ul><li><strong>文件描述符溢出：</strong>  xv6限制fd的范围为0~15，而每次pipe()都会创建两个新的fd，如果不及时关闭不需要的fd，会导致文件描述符资源用尽。这里使用重定向到标准I&#x2F;O的方式来避免生成新的fd，首先close()关闭标准I&#x2F;O的fd，然后使用dup()复制所需的管道fd（会自动复制到序号最小的fd，即关闭的标准I&#x2F;O），随后对pipe两侧fd进行关闭（此时只会移除描述符，不会关闭实际的file对象）。</li><li><strong>pipeline关闭：</strong>  在完成素数输出后，需要依次退出pipeline上的所有进程。在退出父进程前关闭其标准输入fd，此时read()将读取到eof（值为0），此时同样关闭子进程的标准输入fd，退出进程，这样进程链上的所有进程就可以退出。</li><li>参考于：<a href="https://zhayujie.com/mit6828-lab-util.html">https://zhayujie.com/mit6828-lab-util.html</a></li></ul><p>运行测试：</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309121629185.png" alt="image-20230912162954933"></p><p>提示</p><ul><li><p>请牢记这个题目的要求是<strong>通过多线程来加速素数筛</strong>，在编写程序时要检查自己的程序是否满足并发，<strong>一定不要在父进程写入所有数字后子进程才开始处理！</strong>即使这样也能通过测试。</p></li><li><p>请小心关闭进程不需要的文件描述符，否则程序将在第一个进程达到 35 之前耗尽xv6的资源。（<strong>及时关闭管道非常重要！！！</strong>）</p></li><li><p>当一个进程读取完所有数字后，应该等到所有他的子进程终止才能终止，从而避免产生僵尸进程。（善用<code>ctrl+p</code>）</p></li><li><p>当一个管道的写端被关闭时，对读端进行<code>read</code>会返回0。</p></li><li><p>写入所有数字后<strong>再写入一个0来表示写入完毕</strong>，否则子进程无法知道父进程是否写入完毕。采取这种做法是因为执行了<code>fork</code>后父进程才关闭管道写端，子进程并不能感应到管道写端已经关闭了。</p></li><li><p>参考于：<a href="https://zhuanlan.zhihu.com/p/547418924">https://zhuanlan.zhihu.com/p/547418924</a></p></li></ul><p>前置知识：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;*1、write()函数： ssize_t write(int fd,const void*buf,size_t count);参数说明：  fd:是文件描述符（write所对应的是写，即就是1）  buf:通常是一个字符串，需要写入的字符串  count：是每次写入的字节数返回值：  成功：返回写入的字节数  失败：返回-1并设置errno2、read()函数:  ssize_t read(int fd,void*buf,size_t count)      功能:  用于从文件描述符对应的文件读取数据（从打开的设备或文件中读取数据）参数说明:fd:      是文件描述符buf:     为读出数据的缓冲区；count:   为每次读取的字节数（是请求读取的字节数，读上来的数据保         存在缓冲区buf中，同时文件的当前读写位置向后移）返回值： 成功：返回读出的字节数 失败：返回-1，并设置errno，如果在调用read之前到达文件末尾，则这次read返回0    *&#x2F;  &#x2F;&#x2F;示例：int main()&#123;   const char*msg&#x3D;&quot;hello\n&quot;;   int len &#x3D; strlen(msg);   write(1,msg,len);&#x2F;&#x2F;write所对应的文件描述符为1   char buf[1024]&#x3D;&#123;0&#125;;   read(0,buf,len);&#x2F;&#x2F;read所对应的文件描述符为0   return 0;&#125;</code></pre><p>首先打开提示给出的链接，阅读并观察上面给出的图。由图可见，首先将数字全部输入到最左边的管道，然后第一个进程打印出输入管道的第一个数 2 ，并将管道中所有 2 的倍数的数剔除。接着把剔除后的所有数字输入到右边的管道，然后第二个进程打印出从第一个进程中传入管道的第一个数 3 ，并将管道中所有 3 的倍数的数剔除。接着重复以上过程，最终打印出来的数都为素数。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &quot;kernel&#x2F;types.h&quot;#include &quot;user&#x2F;user.h&quot;void process(int p[])&#123;    close(p[1]);&#x2F;&#x2F;关闭向管道写端口    int prime;    if (read(p[0], &amp;prime, 4) &gt; 0) &#123;         fprintf(1, &quot;prime %d\n&quot;, prime);        int p2[2];        pipe(p2);        if (fork() &gt; 0) &#123;&#x2F;&#x2F;parent父进程            close(p2[0]);&#x2F;&#x2F;关闭读端口            int i;            while(read(p[0], &amp;i, 4) &gt; 0) &#123;                if (i % prime !&#x3D; 0) &#123; &#x2F;&#x2F;筛出能被prime整除的数                    write(p2[1], &amp;i, 4);&#x2F;&#x2F;剩下不能被整除的数写进管道                &#125;            &#125;            close(p2[1]);            wait(0);        &#125; else &#123; &#x2F;&#x2F;子进程递归            close(p[0]);            process(p2);        &#125;    &#125;&#125;int main(int argc, char* argv[])&#123;    int p[2];    pipe(p);    int pid &#x3D; fork();    if (pid &gt; 0) &#123; &#x2F;&#x2F; parent 父进程        close(p[0]);        fprintf(1, &quot;prime 2\n&quot;);        for (int i &#x3D; 3; i &lt;&#x3D; 35; ++i) &#123;            if (i % 2 !&#x3D; 0) &#123; &#x2F;&#x2F;不能被2整除的数写进管道                write(p[1], &amp;i, 4);            &#125;        &#125;        close(p[1]);  &#x2F;&#x2F;关闭写端口        wait(0);    &#125; else &#123;&#x2F;&#x2F;子进程 递归操作        process(p);    &#125;    exit(0);&#125;</code></pre><h3 id="Lab01-4-find-c"><a href="#Lab01-4-find-c" class="headerlink" title="Lab01-4:find.c"></a>Lab01-4:find.c</h3><p>编写一个简单版本的 UNIX 查找程序：在目录树中查找名称与字符串匹配的所有文件。</p><p><strong>提示：</strong></p><ul><li>查看 user&#x2F;ls.c 以了解如何读取目录。</li><li>使用递归允许查找下降到子目录。</li><li>不要递归到“。” 和 ”..”。</li></ul><p>从ls.c稍加修改即可：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F;ls.c#include &quot;kernel&#x2F;types.h&quot;#include &quot;kernel&#x2F;stat.h&quot;#include &quot;user&#x2F;user.h&quot;#include &quot;kernel&#x2F;fs.h&quot;&#x2F;&#x2F; linux目录的形式是 &#x2F;bin  前面有个&#x2F;char *fmtname(char *path)&#123;    static char buf[DIRSIZ + 1];    char *p;    &#x2F;&#x2F; Find first character after last slash.    for (p &#x3D; path + strlen(path); p &gt;&#x3D; path &amp;&amp; *p !&#x3D; &#39;&#x2F;&#39;; p--)        ;    p++;    &#x2F;&#x2F; Return blank-padded name.    if (strlen(p) &gt;&#x3D; DIRSIZ)        return p;    memmove(buf, p, strlen(p));    memset(buf + strlen(p), &#39; &#39;, DIRSIZ - strlen(p));    return buf;&#125;void ls(char *path)&#123;    char buf[512], *p;    int fd;    struct dirent de; &#x2F;&#x2F;这个指的是目录项这一结构体（在kernel&#x2F;fs.h中定义），其实目录也是一种文件，里面就是存放了一系列的目录项    struct stat st;   &#x2F;&#x2F;这个指的是文件的统计信息（在kernel&#x2F;stat.h中定义），包含文件类型（目录或文件）&#x2F;inode&#x2F;文件引用nlink&#x2F;文件大小&#x2F;存放fs的disk dev    if ((fd &#x3D; open(path, 0)) &lt; 0)    &#123; &#x2F;&#x2F;打开文件，第二个参数指示的是打开方式，0代表的是O_RDONLY只读的形式。返回值是file descriptor &gt;&#x3D;0，&lt;0说明open失败        fprintf(2, &quot;ls: cannot open %s\n&quot;, path);        return;    &#125;    if (fstat(fd, &amp;st) &lt; 0)    &#123; &#x2F;&#x2F; fstat的含义同open类似        fprintf(2, &quot;ls: cannot stat %s\n&quot;, path);        close(fd);        return;    &#125;    switch (st.type)    &#123;&#x2F;&#x2F; switch 中主要是两个逻辑，一个是文件如何处理，一个是目录怎么处理    case T_FILE:&#x2F;&#x2F;如果是文件，直接打印信息        printf(&quot;%s %d %d %l\n&quot;, fmtname(path), st.type, st.ino, st.size);            &#x2F;&#x2F; st.type中三个值分别是(&#123;1:目录,2:文件,3:console&#125;) fmtname返回值就是文件名称        break;    case T_DIR:        if (strlen(path) + 1 + DIRSIZ + 1 &gt; sizeof buf)        &#123; &#x2F;&#x2F;检查缓存有没有溢出            printf(&quot;ls: path too long\n&quot;);            break;        &#125;        strcpy(buf, path);        p &#x3D; buf + strlen(buf);        *p++ &#x3D; &#39;&#x2F;&#39;; &#x2F;&#x2F;拼接字符串，以路径名访问这个目录里面的内容        while (read(fd, &amp;de, sizeof(de)) &#x3D;&#x3D; sizeof(de))        &#123;&#x2F;&#x2F;访问目录内容。每次read只是read一个de的大小（也就是一个目录项），只有read到最后一个目录项的下一次read才会返回0，也就不满足while循环条件退出循环，            if (de.inum &#x3D;&#x3D; 0) &#x2F;&#x2F;此文件夹无文件，continue操作后进行下一次read                continue;            memmove(p, de.name, DIRSIZ);             &#x2F;&#x2F; memmove为内存之间的迁移，在ls.c里面的意思就是将de.name的内容移动到p指向的指针中            p[DIRSIZ] &#x3D; 0;            if (stat(buf, &amp;st) &lt; 0)            &#123;                printf(&quot;ls: cannot stat %s\n&quot;, buf);                continue;            &#125;            printf(&quot;%s %d %d %d\n&quot;, fmtname(buf), st.type, st.ino, st.size);        &#125;        break;    &#125;    close(fd);&#125;int main(int argc, char *argv[])&#123;    int i;    if (argc &lt; 2)    &#123;        ls(&quot;.&quot;); &#x2F;&#x2F;默认展示当前工作目录的所有文件        exit(0);    &#125;    for (i &#x3D; 1; i &lt; argc; i++)        ls(argv[i]); &#x2F;&#x2F; ls 和我们熟知的linux的ls是不太相同的，xv6的ls是可以接受多个目录作为参数的    exit(0);&#125;&#x2F;&#x2F; kernel&#x2F;fs.hstruct dirent&#123;    ushort inum;    char name[DIRSIZ];&#125;;&#x2F;&#x2F; kernel&#x2F;stat.h#define T_DIR 1    &#x2F;&#x2F; Directory#define T_FILE 2   &#x2F;&#x2F; File#define T_DEVICE 3 &#x2F;&#x2F; Devicestruct stat&#123;    int dev;     &#x2F;&#x2F; File system&#39;s disk device    uint ino;    &#x2F;&#x2F; Inode number    short type;  &#x2F;&#x2F; Type of file    short nlink; &#x2F;&#x2F; Number of links to file    uint64 size; &#x2F;&#x2F; Size of file in bytes&#125;;</code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &quot;kernel&#x2F;types.h&quot;#include &quot;kernel&#x2F;stat.h&quot;#include &quot;user&#x2F;user.h&quot;#include &quot;kernel&#x2F;fs.h&quot; char*fmtname(char *path) &#x2F;&#x2F;格式化名字，把名字变成前面没有左斜杠&#x2F;，仅仅保存文件名&#123;  static char buf[DIRSIZ+1];  char *p;   &#x2F;&#x2F; Find first character after last slash.  for(p&#x3D;path+strlen(path); p &gt;&#x3D; path &amp;&amp; *p !&#x3D; &#39;&#x2F;&#39;; p--)    ;  p++;   &#x2F;&#x2F; Return blank-padded name.  memmove(buf, p, strlen(p) + 1);  return buf;&#125; voidfind(char *path, char* findName)&#123;  char buf[512], *p;  int fd;  struct dirent de;  struct stat st;   if((fd &#x3D; open(path, 0)) &lt; 0)&#123;    fprintf(2, &quot;find: cannot open %s\n&quot;, path);    return;  &#125;   if(fstat(fd, &amp;st) &lt; 0)&#123;    fprintf(2, &quot;find: cannot stat %s\n&quot;, path);    close(fd);    return;  &#125;   switch(st.type)&#123;  case T_FILE:&#x2F;&#x2F; 如果是文件类型，那么比较，文件名是否匹配，匹配则输出    if(strcmp(fmtname(path), findName) &#x3D;&#x3D; 0)      printf(&quot;%s\n&quot;, path);    break;  case T_DIR:&#x2F;&#x2F;如果是目录则递归去查找    if(strlen(path) + 1 + DIRSIZ + 1 &gt; sizeof buf)&#123;&#x2F;&#x2F;检查缓存有没有溢出      printf(&quot;find: path too long\n&quot;);      break;    &#125;    strcpy(buf, path);    p &#x3D; buf+strlen(buf);    &#x2F;&#x2F;拼接字符串，以路径名访问这个目录里面的内容    *p++ &#x3D; &#39;&#x2F;&#39;;&#x2F;&#x2F;buf是一个绝对路径，p是一个文件名，并通过加&quot;&#x2F;&quot;前缀拼接在buf的后面    while(read(fd, &amp;de, sizeof(de)) &#x3D;&#x3D; sizeof(de))&#123;      if(de.inum &#x3D;&#x3D; 0) &#123;&#x2F;&#x2F;此文件夹无文件，continue操作后进行下一次read         continue;        &#125;      memmove(p, de.name, DIRSIZ);&#x2F;&#x2F;memmove, 把de.name信息复制p,其中de.name是char name[255],代表文件名      p[strlen(de.name)] &#x3D; 0; &#x2F;&#x2F; 设置文件名结束符        if(strcmp(de.name, &quot;.&quot;) &#x3D;&#x3D; 0 || strcmp(de.name, &quot;..&quot;) &#x3D;&#x3D; 0) &#123;                continue;        &#125;        find(buf, findName);    &#125;    break;  &#125;  close(fd);&#125; intmain(int argc, char *argv[])&#123;   if(argc &lt; 3)&#123;        printf(&quot;error argc num&quot;);    exit(0);  &#125;  find(argv[1], argv[2]);  exit(0);&#125;</code></pre><h3 id="Lab01心得"><a href="#Lab01心得" class="headerlink" title="Lab01心得"></a>Lab01心得</h3><p>上学期学习操作系统的时候跟着学了一小段的xv6，从刚开始的配置环境配了大几天（早知道还得是用docker），之后换了镜像，这学期居然课程项目还是这个xv6（悲），。。但是在这么折腾配置环境的锻炼下，这次重新配置环境非常快（同时也对我学习其他linux环境下的软件等都很有帮助，遇到问题也会积极的去排查）。</p><p>这几个实验上学期都做过了，这次重新做，顺便整理了笔记，也把每一个lab都看懂了，之前饶有兴趣看了xv6下的user还要kernel的源码（肯定看的不多而且看不太懂），在这之前会以为shell是个很深的东西，实际上也就是一个个命令文件以及内核文件组成的，可以随意自定义操作命令，也可以自定义shell终端页面：</p><p>蛮有意思的。</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309131350576.png" alt="image-20230913135024489"></p><h2 id="Lab02-system-call"><a href="#Lab02-system-call" class="headerlink" title="Lab02 system call"></a>Lab02 system call</h2><h3 id="Lab02-1-system-call"><a href="#Lab02-1-system-call" class="headerlink" title="Lab02-1:system call"></a>Lab02-1:system call</h3><p>实验地址：<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/syscall.html">https://pdos.csail.mit.edu/6.S081/2020/labs/syscall.html</a></p><p>前置知识：gdb调试    <a href="https://www.chens.life/posts/mit-xv6-lab2/">https://www.chens.life/posts/mit-xv6-lab2/</a>     </p><p><strong>配合别人的博客笔记一起食用：</strong><a href="https://ttzytt.com/2022/07/xv6_lab2_record/index.html">https://ttzytt.com/2022/07/xv6_lab2_record/index.html</a>     （必看！！）</p><p><a href="https://miaochenlu.github.io/2020/12/16/xv6-lab2/">https://miaochenlu.github.io/2020/12/16/xv6-lab2/</a></p><hr><p>Lab要求：实现一个追踪特定进程系统调用的系统调用，叫做 trace。比如有个进程调用了这个 trace，那么 trace 就会以特定格式输出这个进程调用过的系统调用。其中，有一个 mask 作为参数，指定有哪些调用需要被追踪。</p><p>实验主页给出了trace执行的四个例子：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ trace 32 grep hello README3: syscall read -&gt; 10233: syscall read -&gt; 9663: syscall read -&gt; 703: syscall read -&gt; 0$#打印内容仅打印了grep跟踪read系统调用。32&#x3D;2^5，“The 32 is 1&lt;&lt;SYS_read.”，也就是说执行这行命令，只跟踪系统调用号为5的执行过程，看到后面的syacall.h就会发现SYS_read&#x3D;5,也就是read的这个调用号就是5，所以输出只打印出了read的调用过程。--------------------------------------------$ trace 2147483647 grep hello README4: syscall trace -&gt; 04: syscall exec -&gt; 34: syscall open -&gt; 34: syscall read -&gt; 10234: syscall read -&gt; 9664: syscall read -&gt; 704: syscall read -&gt; 04: syscall close -&gt; 0$#2147483647即01111111111111111111111111111111，其低31为全部为 1 ，就证明 30号（包括30号）以下的系统调用都需要跟踪）#2147483647这是int整型的最大值，足以包括所有的系统调用号，因此这是打印出执行命令整个过程的所有的系统调用。--------------------------------------------$ grep hello README$#没调用trace，不打印调用过程的任何内容，只执行命令。--------------------------------------------$ trace 2 usertests forkforkforkusertests starting         #表示表示 usertests 进程已开始执行test forkforkfork: 407: syscall fork -&gt; 408  #表示进程 407 执行了系统调用 fork，创建了一个子进程 408408: syscall fork -&gt; 409  #表示进程 408 执行了系统调用 fork，创建了一个子进程 409409: syscall fork -&gt; 410  #....类似上面。。。410: syscall fork -&gt; 411409: syscall fork -&gt; 412410: syscall fork -&gt; 413409: syscall fork -&gt; 414411: syscall fork -&gt; 415...#2&#x3D;2^1,也就是传入的系统调用号为1，找到syscall.h中对应的SYS_fork&#x3D;1,因此这行命令表示使用 trace 命令对 usertests forkforkfork 程序进行详细的系统调用追踪。forkforkfork是系统没有的，自定义的测试命令，这个命令不断的生成子进程，每个子进程中都会再次调用 fork，从而创建更多的子进程，形成进程树的结构。</code></pre><p>附：xv6的系统调用（ 查看 kernel&#x2F;syscall.h）</p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309151905003.png" alt="image-20230915190519923" style="zoom: 60%;" align="left" /><p>看完几篇博客，略懂了系统调用的大致过程。下面着手做实验：</p><p>实验步骤</p><p>1、先切换到syscalll分支：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">git fetchgit checkout syscall</code></pre><p>再次进入&#x2F;user&#x2F;即可看到新增了trace.c。vim查看：</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309152107619.png" alt="image-20230915210713497"></p><p>2、确保正确编译trace.c</p><p>直接添加$U_&#x2F;trace\到Makefile，再执行编译后发现编译失败。</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309152117055.png" alt="image-20230915211726993"></p><p>课程主页也详细说明了操作步骤：</p><p>Some hints:  </p><ul><li><p>Add <code>$U/_trace</code> to UPROGS in Makefile            添加$U&#x2F;_trace</p></li><li><p>Run make qemu and you will see that the compiler cannot compile <code>user/trace.c</code>, because the user-space stubs for the system call don’t exist yet:   下面是需要更改的文件：</p><p><strong>add a prototype for the system call to <code>user/user.h</code>, a stub to <code>user/usys.pl</code>, and a syscall number to <code>kernel/syscall.h</code>.  The Makefile invokes the perl script <code>user/usys.pl</code>, which produces <code>user/usys.S</code>,  the actual system call stubs, which use the RISC-V <code>ecall</code> instruction to transition to the kernel. Once you fix the compilation issues,  run trace 32 grep hello README; it will fail because you haven’t implemented the system call in the kernel yet.</strong>        </p></li><li><p>Add a <code>sys_trace()</code> function in <code>kernel/sysproc.c</code> that implements the new system call by remembering its argument in a new variable in the <code>proc</code> structure (see <code>kernel/proc.h</code>). The functions to retrieve system call arguments from user space are in <code>kernel/syscall.c</code>, and you can see examples        of their use in <code>kernel/sysproc.c</code>.   </p></li><li><p>Modify <code>fork()</code> (see <code>kernel/proc.c</code>) to copy    the trace mask from the parent to the child process. </p></li><li><p>Modify the <code>syscall()</code> function in <code>kernel/syscall.c</code> to print the trace output. You will need to add an array of syscall names to index into.</p></li></ul><hr><p>因此这步要做的就是将trace这个命令加载到系统调用，添加一些内容到一些文件里面去。</p><p>首先是在用户态的 <code>user/user.h</code> 中申明一下，使得用户能通过调用这个接口去调用汇编代码，从而进入内核：</p><p><img src="C:/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/image-20230915212348816.png" alt="image-20230915212348816"></p><p>新增在了第25行，接受一个参数为mask，即系统调用号。</p><p>如前文所讲，我们需要使用汇编去实现这个跳转函数。不过，这个汇编是 perl 的脚本自动生成的，所以需要去更改这个脚本（<code>user/usys.pl</code>）。</p><p>vim进入usys.pl，并在最后新增：entry(“trace”);   </p><p><img src="C:/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/image-20230915212714998.png" alt="image-20230915212714998"></p><p>（注：之后我们 make qemu 的时候，在脚本中新加的这个 entry 就会在 user&#x2F;usys.S 中输出：）</p><pre class="line-numbers language-nasm" data-language="nasm"><code class="language-nasm">.global tracetrace: li a7, SYS_trace ecall ret</code></pre><p>把SYS_trace这个系统调用号放入寄存器a7，然后ecall进入内核模式。</p><p>到此为止已经完成了在用户态的注册。接下来需要在内核中注册。现在我们需要在 <code>kernel/syscall.h</code> 给这个新的调用注册一个调用号，这样才能通过调用号找到函数。</p><p>vim syscall.h </p><p>在最后添加： #define SYS_trace  22</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309152129423.png" alt="image-20230915212920365"></p><p>然后，就像之前介绍的，内核中的中转函数 <code>syscall()</code> 需要通过一个函数指针数组来查找需要调用的函数，所以我们需要去在这个数组中新加一个元素，并且申明一下这个 trace 函数。</p><p>vim进入&#x2F;kernel&#x2F;syscall.c：</p><p>更改在104行以及130行：extern uint64 sys_trace(void);              [SYS_trace] sys_trace, </p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309152132936.png" alt="image-20230915213251819"></p><p>这里 <code>[SYS_trace] sys_trace</code> 是 C 语言数组的一个语法，表示以方括号内的值作为元素下标。比如 <code>int arr[] = &#123;[3] 2333, [6] 6666&#125;</code> 代表 arr 的下标 3 的元素为 2333，下标 6 的元素为 6666，其他元素填充 0 的数组。（该语法在 C++ 中已不可用）</p><hr><p>如前文所讲，像 extern uint64 sys_trace(void); 这样的申明是在 kernel&#x2F;syscall.c 中的，而实现在 kernel&#x2F;sysproc.c 中，我们需要到这个文件中随便添加一个实现（具体的实现在下文讲）。</p><p>注意在这里只是添加了测试代码，用于测试trace是否能正确编译。具体实现在后面还会写到。</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309152213277.png" alt="image-20230915221338187"></p><p>在最后添加上面的代码。保存退出，再重新make qemu，就可以正常编译了。</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309152215059.png" alt="image-20230915221550839"></p><p>测试一下trace命令，trace 32 grep hello README，看到hello from trace 即<strong>代表成功</strong>。（是不是很眼熟，就是上面sys_trace函数的printf）</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309152216021.png" alt="image-20230915221645821"></p><p>ctrl a  x 退出xv6</p><hr><p><strong>hh刚刚只是在实现trace命令能够编译，但还没有实现它的追踪功能。。。@__@</strong></p><hr><p><strong>接下来针对trace的追踪功能进行实现。</strong></p><p>trace追踪功能，想要了解使用了哪些系统调用，其实可以直接在系统调用的中转函数中做一些手脚，因为用户程序想要使用任何的系统服务都需要经过这个函数。那么就可以直接在这个函数中输出 trace 的信息了。</p><p>但是可能同时有很多个进程都在使用系统调用，而直接在 <code>syscall()</code> 函数中输出的话，就不只是输出一个进程使用的系统调用了。</p><p>而且直接输出的话也不符合 lab 中对 mask 的要求（也就是指定输出哪些系统调用）。</p><p>所以我们必须要有一种方法来确定当前的进程是否希望 trace，如果希望，那是希望 trace 哪些系统调用（也就是 mask）。要达到这个要求我们可以直接去给描述进程的结构体加一个 mask 属性。而定义进程的结构体就是 <code>struct proc</code>，在 <code>kernel/proc.h</code> 这个文件中：</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309152224830.png" alt="image-20230915222405713"></p><p>在最后添加上面的代码  int  trace_mask。</p><p>这样，在中转函数 <code>syscall()</code> 中，我们只需要检测当前进入内核的这个进程的 <code>trace_mask</code> 就行了。如果发现这个进程希望追踪现在它调用的这个系统调用，我们就可以直接输出了。这样一来，就不会随便碰到一个进程就输出信息了。</p><p>下面是修改过的 <code>syscall()</code> 函数，在 <code>kernel/syscall.c</code> 中。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">const static *syscall_names[] &#x3D; &#123;  &quot;fork&quot;, &quot;exit&quot;, &quot;wait&quot;, &quot;pipe&quot;, &quot;read&quot;, &quot;kill&quot;, &quot;exec&quot;, &quot;fstat&quot;, &quot;chdir&quot;, &quot;dup&quot;,  &quot;getpid&quot;, &quot;sbrk&quot;, &quot;sleep&quot;, &quot;uptime&quot;, &quot;open&quot;, &quot;write&quot;, &quot;mknod&quot;, &quot;unlink&quot;, &quot;link&quot;,  &quot;mkdir&quot;, &quot;close&quot;, &quot;trace&quot;, &quot;sysinfo&quot;&#125;;voidsyscall(void)&#123;    int num;    struct proc *p &#x3D; myproc();  &#x2F;&#x2F; myproc() 会给出当前调用系统调用的进程    num &#x3D; p-&gt;trapframe-&gt;a7;     &#x2F;&#x2F; 当前进程希望调用的系统调用    if (num &gt; 0 &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;        p-&gt;trapframe-&gt;a0 &#x3D; syscalls[num](); &#x2F;&#x2F; 通过 num 找到需要调用哪个函数        &#x2F;&#x2F; 这个 a0 储存了系统调用的返回值        int trace_mask &#x3D; p-&gt;trace_mask;     &#x2F;&#x2F; 检查这个进程的 trace mask        if ((trace_mask &gt;&gt; num) &amp; 1) &#123;      &#x2F;&#x2F; 如果当前这个系统调用是进程希望追踪的，那就输出          &#x2F;&#x2F; 3: syscall read -&gt; 1023 是 lab 中要求的格式，所以我们也按照这个格式输出          &#x2F;&#x2F; 这里的 3 是进程号，read 是调用的系统调用的名字，1023 是调用过后的返回值。          printf(&quot;%d: syscall %s -&gt; %d\n&quot;, p-&gt;pid, syscall_names[num - 1], p-&gt;trapframe-&gt;a0);        &#125;    &#125; else &#123;        printf(&quot;%d %s: unknown sys call %d\n&quot;, p-&gt;pid, p-&gt;name, num);        p-&gt;trapframe-&gt;a0 &#x3D; -1;    &#125;&#125;</code></pre><p>上面代码，新增了syscall_names[]数组，再对syscall函数进行了修改；（复制粘贴失效时重启虚拟机即可解决）</p><p>修改之后如下：（新增syscall_names[]数组，还有151-153行）</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309152248588.png" alt="image-20230915224756479"></p><p>不过，每个进程的 <code>trace_mask</code> 也不是凭空出现的，只有调用了 trace 这个系统调用，我们才会给进程增加一个 <code>trace_mask</code>。</p><p>所以肯定不能像刚才那样在实现 <code>sys_trace()</code> 时，直接输出一个 hello from trace\texttt{hello from trace}hello from trace。</p><p>下面就是修改后的 <code>sys_trace</code> 的实现。</p><p>vim  sysproc.c    修改之前的代码，如下：</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309152345706.png" alt="image-20230915234534627"></p><p>注意这里：：不要按网上的教程写成 if(argint(0, &amp;mask)) &lt; 0)。。。后面报错找答案搞了半个小时，问了gpt才知道。这个argint返回值是void，不能进行条件判断。所以要单独写出来。</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309152350163.png" alt="image-20230915235008058"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">uint64 sys_trace()&#123;  int mask;  argint(0, &amp;mask)  &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;！！！！！！！！！！！！！！  if(mask) &lt; 0)&#123;    &#x2F;&#x2F;从用户态读取第 0 个 32 位的数据    return - 1;  &#125;  struct proc *cur_proc &#x3D; myproc(); &#x2F;&#x2F; 进行系统调用的这个进程  cur_proc-&gt;trace_mask &#x3D; mask;  return 0;&#125;</code></pre><p><em>本质上很简单，我们在用户态调用 <code>trace()</code> 时，会传进去一个 <code>mask</code>，而现在这个系统调用实际上就是把传进来的这个 mask 赋值到当前的 <code>struct proc</code> 上。这样之后经过中转函数时，就可以知道要追踪哪些系统调用了。</em></p><p><em>注意这里的 <code>argint(0, &amp;mask)</code> 这句话，其用处是读取第一个 323232 位的参数。</em></p><p>最后收尾工作的函数（感觉有点像是 C++ 里的析构函数）就是 <code>freeproc()</code>，也和 <code>allocproc()</code> 一起，在 <code>kernel/proc.c</code> 这个文件中。那么我们直接在最后来一句 <code>p-&gt;trace_mask = 0;</code> 就可以了。</p><p>vim  kernel&#x2F;proc.c  </p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309152256360.png" alt="image-20230915225635294"></p><p>到这里，离完成这个 lab 就只剩最后一步了。</p><blockquote><p>  The trace system call should enable tracing for the process that  calls it and any children that it subsequently forks, but should not  affect other processes.</p></blockquote><p>也就是实现这句话说的功能，如果我们的父进程有 <code>trace_mask</code>，子进程也需要有相同的。因为创建子进程都需要用 <code>fork()</code>，那直接去改 <code>fork</code> 的源码就好了：</p><p>vim进入 proc.c：</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309152303080.png" alt="image-20230915230305961"></p><p><code>fork()</code> 的具体实现和上面的两个函数一样，还是在 <code>kernel/proc.c</code> 中（毕竟和进程有关）。</p><p>可以看到，第一行定义了两个 <code>struct proc</code>，一个是 <code>np</code>，一个是 <code>p</code>。因为代码中的注释，所以很明显可以看出来，这个 <code>np</code> 就是新的进程，那我们就完全不用管这里一堆看不懂的东西了，直接在中间来一个 <code>np-&gt;trace_mask = p-&gt;trace_mask</code>。</p><p>终于</p><p>终于</p><p>。。。。&#x2F;。&#x2F;。&#x2F;。，。，&#x2F;。，。&#x2F;，。。。，；，‘。。。&#x2F;&#x2F;</p><p>&#x3D;&#x3D;完结撒花&#x3D;&#x3D;</p><p>用时 4hour</p><p>感想是好累，。。。。&#x2F;哭&#x2F;  0_0  O.O  o_o</p><hr><p>实际上操作起来不用长时间，直接修改这里的指定文件的代码就好，但是整个学习过程还是很重要的，特别是前面的gdb调试，还有看xv6文档，理解系统调用的整个过程，都是蛮重要的。<br><a href="https://github.com/whileskies/xv6-labs-2020/blob/main/doc/Lab2-system%20calls.md">https://github.com/whileskies/xv6-labs-2020/blob/main/doc/Lab2-system%20calls.md</a></p><p>后续：真坑啊网上的教程。还以为没啥问题了，结果make qemu一跑就报错了。就是在sysproc.c里面的argint函数是没有返回值的，教程的代码错误的在if条件句里面进行判断了。</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309152352456.png" alt="image-20230915235243247"></p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309152358000.png" alt="image-20230915235808942"></p><p>终于能跑出了了。</p><p>时间已经是2023&#x2F;9&#x2F;15 23:52了。</p><p>踩坑日记：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F;  &#x2F;kernel&#x2F;sysproc.c&#x2F;sys_trace()uint64sys_trace()&#123;  int mask;  argint(0, &amp;mask)&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;！！！！这里要单独分出来  if (mask) &lt; 0)      return -1;  struct proc *pro &#x3D; myproc();  printf(&quot;trace pid: %d\n&quot;, pro-&gt;pid);  pro-&gt;trace_mask &#x3D; mask;  return 0;&#125; </code></pre><h2 id="Lab03-1-page-table"><a href="#Lab03-1-page-table" class="headerlink" title="Lab03-1:page table"></a>Lab03-1:page table</h2><p>参考博客：<a href="https://ttzytt.com/2022/07/xv6_note/">https://ttzytt.com/2022/07/xv6_note/</a></p><p><a href="https://ttzytt.com/2022/07/xv6_lab3_record/">https://ttzytt.com/2022/07/xv6_lab3_record/</a></p><p>To help you learn about RISC-V page tables, and perhaps to aid future debugging, your first task is to write a function that prints  the contents of a page table. Now when you start xv6 it should print output like this, describing the page table of the first process at the point when it has just finished <code>exec()</code>ing <code>init</code>:   </p><p>为了帮助您了解RISC-V页表，也许是为了帮助将来进行调试，您的第一个任务是编写一个打印页表内容的函数。</p><p>定义一个名为 <code>vmprint()</code> 的函数。它应该接受一个 <code>pagetable_t</code> 参数，并以下面描述的格式打印该分页表。在 exec.c 中插入 <code>if(p-&gt;pid==1) vmprint(p-&gt;pagetable)</code> 的 <code>return argc</code> 前面，以打印第一个进程的页表。</p><p>现在当你启动 xv6 时，它应该像这样打印输出，描述第一个进程在刚刚完成 <code>exec()</code> ing <code>init</code> 时的页表：</p><pre class="line-numbers language-none"><code class="language-none">page table 0x0000000087f6e000..0: pte 0x0000000021fda801 pa 0x0000000087f6a000.. ..0: pte 0x0000000021fda401 pa 0x0000000087f69000.. .. ..0: pte 0x0000000021fdac1f pa 0x0000000087f6b000.. .. ..1: pte 0x0000000021fda00f pa 0x0000000087f68000.. .. ..2: pte 0x0000000021fd9c1f pa 0x0000000087f67000..255: pte 0x0000000021fdb401 pa 0x0000000087f6d000.. ..511: pte 0x0000000021fdb001 pa 0x0000000087f6c000.. .. ..510: pte 0x0000000021fdd807 pa 0x0000000087f76000.. .. ..511: pte 0x0000000020001c0b pa 0x0000000080007000</code></pre><p>第一行显示 的 <code>vmprint</code> 参数。之后，每个 PTE 都有一行，包括引用树中更深处的页表页面的 PTE。每条 PTE 线都缩进了一个数字 <code>&quot; ..&quot;</code> ，表示其在树中的深度。每个 PTE 行在其页表页中显示 PTE 索引、pte 位以及从 PTE 中提取的物理地址。不要打印无效的  PTE。在上面的示例中，顶级页表页具有条目 0 和 255 的映射。条目 0 的下一级仅映射索引 0，该索引 0 的下一级映射了条目 0、1 和 2。</p><p>Some hints:</p><pre class="line-numbers language-none"><code class="language-none">1.将vmprint()放进kernel&#x2F;vm.c2.使用文件 kernel&#x2F;riscv.h 末尾的宏3.在 kernel&#x2F;defs.h 中定义原型 vmprint ，以便可以从 exec.c 调用它4.可以参照freewalk.c进行递归遍历5.%p 在 printf 调用中使用以打印出完整的 64 位十六进制 PTE 和地址，如示例中所示</code></pre><p>实现代码:</p><p>先切换分支</p><pre class="line-numbers language-none"><code class="language-none">git checkout pgtbmake clean</code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c">void vmprint(pagetable_t pagetable, uint dep)&#123;  if(dep &#x3D;&#x3D; 0)    printf(&quot;page table %p\n&quot;, pagetable);  for(int i &#x3D; 0; i &lt; 512; i++)&#123;    pte_t pte &#x3D; pagetable[i];    if(pte &amp; PTE_V)&#123;      for(int j &#x3D; 0; j &lt; dep; j++)        printf(&quot;.. &quot;);      uint64 child &#x3D; PTE2PA(pte);      printf(&quot;..%d: pte %p pa %p\n&quot;, i, pte, child);      if(dep &lt; 2)        &#x2F;&#x2F; 如果层数等于 2 就不需要继续递归了，因为这是叶子节点        vmprint((pagetable_t) child, dep + 1);    &#125;  &#125; &#125;</code></pre><p>对于每个 <code>pagetable</code>，最多有 512 个节点，所以我们就依次遍历它们。如果发现这个页表是已分配的，也就是符合 <code>pte &amp; PTE_V == 1</code> 的，我们就继续递归。</p><p>在打印的时候，我们先需要打印出 <code>dep + 1</code> 个 <code>..</code>，然后再打印出 pte 和 pa。</p><p>这里指的 pte 指的是直接读取页表项的结果，而 pa 是去掉页表项中的标志位后得到的物理地址，我们通过这个物理地址可以找到下一层的页表项或是页帧。</p><p>注意可以这么 <code>pte_t pte = pagetable[i];</code> 写是因为，pa 指向的实际上是这个子页表的第一个元素，而 <code>pagetable[i]</code> 和 <code>*(pagetable + i)</code> 是等价的，也就是去访问第 i 个页表。</p><p>第一步：在&#x2F;kernel&#x2F;vm.c  最后新增代码段，保存退出</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309162323397.png" alt="image-20230916232306105"></p><p>第二步：然后在kernel&#x2F;exec.c中找到exec函数，添加代码段</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">if(p-&gt;pid &#x3D;&#x3D; 1)    vmprint(p-&gt;pagetable, 0);</code></pre><p>vim操作快捷键： 查找 &#x2F;xxx  （输入&#x2F;之后输入要查找的内容，比如要查找exec，就输入&#x2F;exec ，查询下一个时，先按回车，再按enter）</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309170911731.png" alt="image-20230917091101655"></p><p>&#x2F;kernel&#x2F;defs.h    在&#x2F;&#x2F;vm.c下面新增 一行  vmprint(pagetable_t,uint dep); 为了exec可以调用。</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309162343273.png"></p><p>最后编译 make qemu即可。</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309162345802.png" alt="image-20230916234541422"></p><p>一些补充：</p><p><strong>pagetable_t</strong>：</p><p>在 xv6 操作系统中，<code>pagetable_t</code> 结构用于表示页表。它是一个包含 512 个 <code>pte_t</code> 元素的数组。</p><p><code>pagetable_t</code> 的定义位于 <code>kernel/riscv.h</code> 文件中，如下所示：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F; Page table descriptor entrytypedef uint64_t pte_t;&#x2F;&#x2F; Page tabletypedef struct &#123;  pte_t ent[512];&#125; pagetable_t;</code></pre><p>上述定义中，<code>pte_t</code> 是一个 64 位的无符号整数类型，用于表示页表项（page table entry）。每个页表项包含有关虚拟地址和物理地址之间映射关系的信息。而 <code>pagetable_t</code> 结构体则由包含 512 个 <code>pte_t</code> 元素的数组 <code>ent</code> 组成，即 <code>ent</code> 是一个长度为 512 的 <code>pte_t</code> 类型的数组。</p><p>通过使用这种结构，xv6 能够灵活地管理和访问页表，以实现虚拟地址到物理地址的映射。</p><h2 id="Lab04-file-system"><a href="#Lab04-file-system" class="headerlink" title="Lab04-file system"></a>Lab04-file system</h2><p>xv6中文手册地址：<a href="http://xv6.dgs.zone/tranlate_books/book-riscv-rev1/c8/s0.html">http://xv6.dgs.zone/tranlate_books/book-riscv-rev1/c8/s0.html</a></p><p>lab地址：<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/fs.html">https://pdos.csail.mit.edu/6.S081/2020/labs/fs.html</a></p><p>参考：<a href="https://ttzytt.com/2022/08/xv6_lab10_record/">https://ttzytt.com/2022/08/xv6_lab10_record/</a></p><p><a href="https://github.com/whileskies/xv6-labs-2020/blob/main/doc/Lab9-file%20system.md">https://github.com/whileskies/xv6-labs-2020/blob/main/doc/Lab9-file%20system.md</a></p><hr><p>xv6book：</p><ul><li><a href="http://xv6.dgs.zone/tranlate_books/book-riscv-rev1/c8/s0.html">http://xv6.dgs.zone/tranlate_books/book-riscv-rev1/c8/s0.html</a></li><li>文件系统需要磁盘上的数据结构来表示目录和文件名称树，记录保存每个文件内容的块的标识，以及记录磁盘的哪些区域是空闲的。</li><li>文件系统必须支持崩溃恢复（crash recovery）。也就是说，如果发生崩溃（例如，电源故障），文件系统必须在重新启动后仍能正常工作。风险在于崩溃可能会中断一系列更新，并使磁盘上的数据结构不一致（例如，一个块在某个文件中使用但同时仍被标记为空闲）。</li><li>不同的进程可能同时在文件系统上运行，因此文件系统代码必须协调以保持不变量。</li><li>访问磁盘的速度比访问内存慢几个数量级，因此文件系统必须保持常用块的内存缓存。</li></ul><p>实现过程：</p><p>1.vim kernel&#x2F;sh.c  </p><p>找到这三行宏定义： 可以通过vim查找 &#x2F;NDIRECT 找到</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309171640492.png" alt="image-20230917164033360"></p><p>修改成：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#define NDIRECT 11#define DINDIRECTI (NDIRECT + 1)#define NINDIRECT (BSIZE &#x2F; sizeof(uint))#define MAXFILE (NDIRECT + NINDIRECT + NINDIRECT * NINDIRECT)</code></pre><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309171642880.png" alt="image-20230917164205815"></p><p>2.vim kernrl&#x2F;file.h</p><p>找到addrs[NDIECT+1];</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309171643389.png" alt="image-20230917164328329"></p><p>修改成uint addrs[NDIRECT+2];</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309171645022.png" alt="image-20230917164529946"></p><p>3.vim &#x2F;kernel&#x2F;fs.h</p><p>找到struct dinode，将addrs[NDIRECT+1]修改成+2</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309171648407.png" alt="image-20230917164838340"></p><p>4.vim kernel&#x2F;fs.c  找到bmap函数，修改成以下代码：</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309171718599.png" alt="image-20230917171828521"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">static uintbmap(struct inode *ip, uint bn)&#123;  uint addr, addr2, *a, *a2;  struct buf *bp, *bp2;  if(bn &lt; NDIRECT)&#123;    if((addr &#x3D; ip-&gt;addrs[bn]) &#x3D;&#x3D; 0)      ip-&gt;addrs[bn] &#x3D; addr &#x3D; balloc(ip-&gt;dev);    return addr;  &#125;  bn -&#x3D; NDIRECT;  if(bn &lt; NINDIRECT)&#123;    &#x2F;&#x2F; Load indirect block, allocating if necessary.    if((addr &#x3D; ip-&gt;addrs[NDIRECT]) &#x3D;&#x3D; 0)      ip-&gt;addrs[NDIRECT] &#x3D; addr &#x3D; balloc(ip-&gt;dev);    bp &#x3D; bread(ip-&gt;dev, addr);    a &#x3D; (uint*)bp-&gt;data;    if((addr &#x3D; a[bn]) &#x3D;&#x3D; 0)&#123;      a[bn] &#x3D; addr &#x3D; balloc(ip-&gt;dev);      log_write(bp);    &#125;    brelse(bp);    return addr;  &#125;    bn -&#x3D; NINDIRECT;  if(bn &lt; NINDIRECT * NINDIRECT)&#123;    uint dbn &#x3D; bn &#x2F; NINDIRECT;    uint dbnoff &#x3D; bn % NINDIRECT;    &#x2F;&#x2F; Load doubly-indirect block, allocating if necessary.    if((addr &#x3D; ip-&gt;addrs[DINDIRECTI]) &#x3D;&#x3D; 0)      ip-&gt;addrs[DINDIRECTI] &#x3D; addr &#x3D; balloc(ip-&gt;dev);    bp &#x3D; bread(ip-&gt;dev, addr);        a &#x3D; (uint*)bp-&gt;data;    if((addr2 &#x3D; a[dbn]) &#x3D;&#x3D; 0)&#123;      a[dbn] &#x3D; addr2 &#x3D; balloc(ip-&gt;dev);      log_write(bp);    &#125;    brelse(bp);    &#x2F;&#x2F;printf(&quot;addr2: %d\n&quot;, addr2);    bp2 &#x3D; bread(ip-&gt;dev, addr2);    a2 &#x3D; (uint*)bp2-&gt;data;    if((addr &#x3D; a2[dbnoff]) &#x3D;&#x3D; 0)&#123;      a2[dbnoff] &#x3D; addr &#x3D; balloc(ip-&gt;dev);      log_write(bp2);    &#125;    brelse(bp2);    return addr;  &#125;  panic(&quot;bmap: out of range&quot;);&#125;</code></pre><p>5.vim  kernel&#x2F;fs.c   找到itrunc函数</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309171720290.png" alt="image-20230917172019225"></p><p>修改成</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">voiditrunc(struct inode *ip)&#123;  int i, j;  struct buf *bp, *bp2;  uint *a, *a2;  for(i &#x3D; 0; i &lt; NDIRECT; i++)&#123;    if(ip-&gt;addrs[i])&#123;      bfree(ip-&gt;dev, ip-&gt;addrs[i]);      ip-&gt;addrs[i] &#x3D; 0;    &#125;  &#125;  if(ip-&gt;addrs[NDIRECT])&#123;    bp &#x3D; bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);    a &#x3D; (uint*)bp-&gt;data;    for(j &#x3D; 0; j &lt; NINDIRECT; j++)&#123;      if(a[j])        bfree(ip-&gt;dev, a[j]);    &#125;    brelse(bp);    bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);    ip-&gt;addrs[NDIRECT] &#x3D; 0;  &#125;  if(ip-&gt;addrs[DINDIRECTI])&#123;    bp &#x3D; bread(ip-&gt;dev, ip-&gt;addrs[DINDIRECTI]);    a &#x3D; (uint*)bp-&gt;data;    for(i &#x3D; 0; i &lt; NINDIRECT; i++)&#123;      if(a[i])&#123;        bp2 &#x3D; bread(ip-&gt;dev, a[i]);        a2 &#x3D; (uint*)bp2-&gt;data;        for(j &#x3D; 0; j &lt; NINDIRECT; j++)&#123;          if(a2[j])            bfree(ip-&gt;dev, a2[j]);        &#125;        brelse(bp2);        bfree(ip-&gt;dev, a[i]);      &#125;    &#125;    brelse(bp);    bfree(ip-&gt;dev, ip-&gt;addrs[DINDIRECTI]);    ip-&gt;addrs[DINDIRECTI] &#x3D; 0;  &#125;  ip-&gt;size &#x3D; 0;  iupdate(ip);&#125;</code></pre><p>6.vim kernel&#x2F;file.c   </p><p>找到filewrite() 中的int max&#x3D;…  一行</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309171721118.png" alt="image-20230917172141017"></p><p>修改成</p><pre class="line-numbers language-none"><code class="language-none">int max &#x3D; ((MAXOPBLOCKS-1-2-2) &#x2F; 2) * BSIZE;</code></pre><p>到此&#x3D;&#x3D;完结撒花&#x3D;&#x3D;</p><p>测试：</p><p>启动xv6，发现可以正常启动，说明代码修改没有出现编译问题。</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309171724792.png" alt="image-20230917172440718"></p><h2 id="Lab05-net-working"><a href="#Lab05-net-working" class="headerlink" title="Lab05-net working"></a>Lab05-net working</h2><p>实验地址：<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/net.html">https://pdos.csail.mit.edu/6.S081/2020/labs/net.html</a></p><p>学习参考：<a href="https://ttzytt.com/2022/08/xv6_lab8_record/">https://ttzytt.com/2022/08/xv6_lab8_record/</a>    &#x3D;&#x3D;必看！！！&#x3D;&#x3D;</p><hr><p>切换分支：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">git  stash save &quot;filesys&quot;   git checkout net make clean</code></pre><p>实验任务：</p><p>完成函数e1000_transmit()   and       e1000_recv()</p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309172129027.png" alt="image-20230917212916907" style="zoom:67%;" /><p>这个实验的lab描述我实在是服了。。长长一大串。。</p><h3 id="一些定义"><a href="#一些定义" class="headerlink" title="一些定义"></a>一些定义</h3><p><strong>vim kernel&#x2F;e1000_dev.h可以看到所有的宏定义</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F;TX表示数据的发送（Transmission），而RX表示数据的接收（Reception）。这个X并没有特定的意义，只是用来代表这两个术语的首字母。&#x2F;&#x2F;发送方#define E1000_RDH      (0x02810&#x2F;4)  &#x2F;* RX Descriptor Head - RW *&#x2F;   头指针#define E1000_RDT      (0x02818&#x2F;4)  &#x2F;* RX Descriptor Tail - RW *&#x2F;   尾指针#define E1000_RDLEN    (0x02808&#x2F;4)  &#x2F;* RX Descriptor Length - RW *&#x2F; 环形队列的长度&#x2F;&#x2F;接收方#define E1000_TDLEN    (0x03808&#x2F;4)  &#x2F;* TX Descriptor Length - RW *&#x2F;#define E1000_TDH      (0x03810&#x2F;4)  &#x2F;* TX Descriptor Head - RW *&#x2F;#define E1000_TDT      (0x03818&#x2F;4)  &#x2F;* TX Descripotr Tail - RW *&#x2F;        &#x2F;&#x2F; [E1000 3.3.3]struct tx_desc   &#x2F;&#x2F;发送方描述结构&#123;  uint64 addr;  uint16 length;  uint8 cso;  uint8 cmd;  uint8 status;  uint8 css;  uint16 special;&#125;;&#x2F;* Receive Descriptor bit definitions [E1000 3.2.3.1] *&#x2F;#define E1000_RXD_STAT_DD       0x01    &#x2F;* Descriptor Done *&#x2F;  #define E1000_RXD_STAT_EOP      0x02    &#x2F;* End of Packet *&#x2F;&#x2F;&#x2F; [E1000 3.2.3]struct rx_desc   &#123;  uint64 addr;       &#x2F;* Address of the descriptor&#39;s data buffer *&#x2F;  uint16 length;     &#x2F;* Length of data DMAed into data buffer *&#x2F;  uint16 csum;       &#x2F;* Packet checksum *&#x2F;  uint8 status;      &#x2F;* Descriptor status *&#x2F;  uint8 errors;      &#x2F;* Descriptor Errors *&#x2F;  uint16 special;&#125;;</code></pre><p>在e1000.c 中 </p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#define TX_RING_SIZE 16static struct tx_desc tx_ring[TX_RING_SIZE] __attribute__((aligned(16)));static struct mbuf *tx_mbufs[TX_RING_SIZE];#define RX_RING_SIZE 16static struct rx_desc rx_ring[RX_RING_SIZE] __attribute__((aligned(16)));static struct mbuf *rx_mbufs[RX_RING_SIZE];</code></pre><hr><h3 id="transmit"><a href="#transmit" class="headerlink" title="transmit()"></a>transmit()</h3><p>发送   e1000_transmit()： </p><p>vim kernel&#x2F;e1000.c    在此处增加代码：</p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309181313776.png" alt="image-20230918131324675" style="zoom: 67%;" /><p>实现代码为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">inte1000_transmit(struct mbuf *m)&#123;  acquire(&amp;e1000_lock);   &#x2F;&#x2F;获取网络设备的锁，确保在使用网络设备时只有一个进程在执行  int tail &#x3D; regs[E1000_TDT];    &#x2F;*    tx_ring[tail].status    用于访问 tx_ring 数组中索引为 tail 的元素的 status 字段。这个字段表示传输描述符（transmit descriptor）的状态。E1000_TXD_STAT_DD 是一个常量值，它表示传输描述符的“传输完成”状态。 这个状态位用于指示数据包已经成功发送。    *&#x2F;  if(!(tx_ring[tail].status &amp; E1000_TXD_STAT_DD))&#123;         release(&amp;e1000_lock);  &#x2F;&#x2F;队列满，释放锁    return -1;&#x2F;&#x2F;返回错误  &#125;    if(tx_mbufs[tail])  &#x2F;&#x2F;释放之前发送队列的末尾tail数据包对应的内存空间（如果存在）    mbuffree(tx_mbufs[tail]);    &#x2F;&#x2F;填充 tx_ring[tail] 数据结构中的字段：cmd 域和 length 域用于控制数据包的发送方式，addr 域指向待发送的数据块的地址；  memset(&amp;tx_ring[tail], 0, sizeof(struct tx_desc));  tx_ring[tail].cmd &#x3D; (E1000_TXD_CMD_EOP | E1000_TXD_CMD_RS);  tx_ring[tail].addr &#x3D; (uint64)m-&gt;head;  tx_ring[tail].length &#x3D; m-&gt;len;  &#x2F;&#x2F;将 m 对应的数据块添加到发送队列中  tx_mbufs[tail] &#x3D; m;     &#x2F;&#x2F;更新 E1000_TDT 寄存器，指向新的尾指针。  regs[E1000_TDT] &#x3D; (tail + 1) % TX_RING_SIZE;      &#x2F;&#x2F;最后函数释放网络设备的锁，并返回 0，表示数据包已经成功添加到发送队列中。  release(&amp;e1000_lock);  return 0;&#125;</code></pre><p>代码中的定义都可以在上面的<strong>一些定义</strong>中看到</p><h3 id="recv"><a href="#recv" class="headerlink" title="recv()"></a>recv()</h3><p>vim kernel&#x2F;e1000.c   e1000_recv(void):</p><p>在23行以及33行添加代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">struct spinlock e1000_lockrx;&#x2F;&#x2F; e1000_init()initlock(&amp;e1000_lockrx, &quot;e1000_rx&quot;);</code></pre><p>插入之后如下所示：</p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309181326166.png" alt="image-20230918132640088" style="zoom:67%;" /><p>接着找到e1000_recv函数：</p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309181316280.png" alt="image-20230918131629212" style="zoom:67%;" /><p>添加代码如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">static voide1000_recv(void)&#123;  while(1)&#123; &#x2F;&#x2F;进入无限循环，不断接受网络数据包    &#x2F;&#x2F;获取下一个接收队列描述符的索引（idx），这里使用了环形缓冲区（RX_RING）来存储接收队列。    uint idx &#x3D; (regs[E1000_RDT] + 1) % RX_RING_SIZE;    &#x2F;&#x2F;根据索引获取该接收队列描述符（desc）的指针    struct rx_desc *desc &#x3D; &amp;rx_ring[idx];     &#x2F;&#x2F;判断该接收队列描述符的状态标志位（status）是否为“数据接收完成”（DD）。如果没有，则返回并等待下一个数据包。    if(!(desc-&gt;status &amp; E1000_RXD_STAT_DD))&#123;      return;    &#125;     &#x2F;&#x2F;从接收缓冲区（rx_mbufs）中获取对应的网络数据包（mbuf），并设置其长度为接收队列描述符中指定的长度。    rx_mbufs[idx]-&gt;len &#x3D; desc-&gt;length;    &#x2F;&#x2F;将该网络数据包传递给net_rx函数进行处理。    net_rx(rx_mbufs[idx]);    &#x2F;&#x2F;分配一个新的接收缓冲区（mbuf），并将其指针存储在接收队列描述符中指定的地址（addr）中    rx_mbufs[idx] &#x3D; mbufalloc(0);    desc-&gt;addr &#x3D; rx_mbufs[idx]-&gt;head;    desc-&gt;status &#x3D; 0;&#x2F;&#x2F;将接收队列描述符的状态标志位清零（status &#x3D; 0）    regs[E1000_RDT] &#x3D; idx;&#x2F;&#x2F;更新接收队列的读指针（E1000_RDT）为下一个接收队列描述符的索引（idx）  &#125;&#125;</code></pre><p>代码中的定义都可以在上面的<strong>一些定义</strong>中看到</p><hr><p>:wq保存退出。重新编译，没出现问题。</p><p>&#x3D;&#x3D;完结撒花&#x3D;&#x3D;</p><p>再说一遍必看：<a href="https://ttzytt.com/2022/08/xv6_lab8_record/">https://ttzytt.com/2022/08/xv6_lab8_record/</a></p><p>终于结束了。真有种轻舟已过万重山的感觉。。。。。😅😅😅😅😅😅😅😅😅😅😅😅😅😅😅😅😅😅😅😅</p><hr><h1 id="学习笔记"><a href="#学习笔记" class="headerlink" title="学习笔记"></a>学习笔记</h1><h2 id="1-1进程和内存"><a href="#1-1进程和内存" class="headerlink" title="1.1进程和内存"></a>1.1进程和内存</h2><p>一、终端执行命令过程：</p><p>用户输入命令，shell通过getcmd()读取一行，然后调用<code>fork</code>创建一个shell进程的副本。父进程调用<code>wait</code>，子进程执行命令。例如：当用户向shell输入echo hello时，runcmd(user&#x2F;sh.c:58) 将以echo hello为参数被调用来执行实际命令。对于“echo hello”，它将调用exec(user&#x2F;sh.c:78)。如果exec成功，那么子进程将从echo而不是runcmd执行命令，在某刻echo会调用exit，这将导致父进程从main(user&#x2F;sh.c:78)中的wait返回。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F; usr&#x2F;sh.cintgetcmd(char *buf, int nbuf)&#123;  write(2, &quot;$ &quot;,2 );   &#x2F;&#x2F;也就是这里可以自定义shell的读取符   memset(buf, 0, nbuf);  gets(buf, nbuf);  if(buf[0] &#x3D;&#x3D; 0) &#x2F;&#x2F; EOF    return -1;  return 0;&#125;</code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c">write(2, &quot;$ &quot;,2 );  &#x2F;&#x2F;每个参数的含义如下：&#x2F;&#x2F;第一个参数 2：表示文件描述符，这里是标准错误输出（stderr）的文件描述符。&#x2F;&#x2F;第二个参数 &quot;&amp; &quot;：表示要写入的数据的起始地址，即一个指向要写入的字符数组的指针。&#x2F;&#x2F;第三个参数 2：表示要写入的数据的长度，即要写入的字符数组的长度。&#x2F;&#x2F;比如可以改成 @-@ ，修改成 write(2,&quot;@-@&quot;,4);  &#x2F;&#x2F;(为了美观一般长度多出个空格)</code></pre><p>在 xv6 操作系统中，<code>runcmd</code> 和 <code>exec</code> 这两个函数都用于运行指令。</p><p><code>runcmd</code> 函数用于解析用户输入的命令，并根据命令类型调用相应的执行函数。它接收一个 <code>struct cmd*</code> 类型的参数，该结构体包含了用户输入的命令的各个部分（例如命令名称、参数等）。<code>runcmd</code> 函数会根据命令的类型，调用相应的执行函数来执行命令。</p><p>对于普通的外部命令（例如 ls、cat 等），<code>runcmd</code> 函数会调用 <code>runcmd_execcmd</code> 函数来执行。<code>runcmd_execcmd</code> 主要的工作是创建一个新的子进程并加载用户空间的程序代码，然后在子进程中使用 <code>exec</code> 系统调用来执行这个命令。这样可以实现在子进程中启动一个新的程序，而不是在当前进程中执行。</p><p>在 <code>exec</code> 系统调用中，将会加载指定程序的代码和数据到内存中，并将进程的上下文切换到新程序的起始点。这样，新程序就可以开始执行了。<code>exec</code> 系统调用会替换当前进程的地址空间，所以在调用后，原进程的代码和数据都被新程序取代了。</p><p>总之，<code>runcmd</code> 函数解析用户输入的命令，根据命令类型调用相应的执行函数。对于外部命令，使用 <code>exec</code> 系统调用在子进程中加载并执行指定的程序。这样就实现了运行指令的功能。</p><h2 id="2-4xv6架构篇"><a href="#2-4xv6架构篇" class="headerlink" title="2.4xv6架构篇"></a>2.4xv6架构篇</h2><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309151718283.png" alt="image-20230915171844153" style="zoom: 50%;" /><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309151719164.png" alt="image-20230915171908066" style="zoom:50%;" /><h1 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h1><h2 id="定制你的shell"><a href="#定制你的shell" class="headerlink" title="定制你的shell"></a>定制你的shell</h2><h3 id="1、-定制shell启动欢迎界面"><a href="#1、-定制shell启动欢迎界面" class="headerlink" title="1、 定制shell启动欢迎界面"></a>1、 定制shell启动欢迎界面</h3><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309152215059.png" alt="image-20230915221550839"></p><p>vim kernel&#x2F;main.c</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309171525400.png" alt="image-20230917152542285"></p><p>在这个位置插入你想自定义的欢迎界面。</p><p>如果你也想有上面的特殊字串，click这个网站：<a href="http://patorjk.com/software/taag/#p=testall&f=Mer&t=Hello%20World">http://patorjk.com/software/taag/#p=testall&amp;f=Mer&amp;t=Hello%20World</a></p><h3 id="2、定制命令提示符"><a href="#2、定制命令提示符" class="headerlink" title="2、定制命令提示符"></a>2、定制命令提示符</h3><p>vim user&#x2F;sh.c   getcmd</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309171529910.png" alt="image-20230917152941849"></p><p>修改write(2,”$”,2);即可。第三个参数2是截取第二个参数字符串的长度。</p><p>修改成学号可更改为 write(2,”20212131102$ “,13);   多留一个空格出来，因此截取长度设置为13。</p><h2 id="linux常用命令"><a href="#linux常用命令" class="headerlink" title="linux常用命令"></a>linux常用命令</h2><p>ls  显示当前目录下所有文件  可选参数 -a  -l </p><p>history  显示输入命令历史</p><p>cd  进入文件夹    cd .. 返回上一级</p><p>cp 拷贝copy        cp A B     把A复制一份并且命名为B</p><p>rm  删除remove      rm a</p><p>mv 重命名   mv a  b  把A重命名为B</p><h2 id="vim常用命令"><a href="#vim常用命令" class="headerlink" title="vim常用命令"></a>vim常用命令</h2><p>i 插入模式</p><p>:set nu  显示行号</p><p>gg 回到顶部</p><p>g跳到尾部</p><p>u撤销</p><p>o在下一行插入</p><p>h j k l   左下上右</p><p>w下一个单词</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;xv6实验&quot;&gt;&lt;a href=&quot;#xv6实验&quot; class=&quot;headerlink&quot; title=&quot;xv6实验&quot;&gt;&lt;/a&gt;xv6实验&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;author&lt;/strong&gt;:  Hopefuling&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;[TOC]&lt;/p&gt;</summary>
      
    
    
    
    
    <category term="xv6" scheme="https://hopefuling.github.io/tags/xv6/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://hopefuling.github.io/2023/09/06/hello-world/"/>
    <id>https://hopefuling.github.io/2023/09/06/hello-world/</id>
    <published>2023-09-06T07:32:59.090Z</published>
    <updated>2023-09-06T07:27:03.734Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>BigData</title>
    <link href="https://hopefuling.github.io/2023/09/01/Hadoop/"/>
    <id>https://hopefuling.github.io/2023/09/01/Hadoop/</id>
    <published>2023-09-01T02:36:03.000Z</published>
    <updated>2023-09-19T10:42:41.498Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-记录"><a href="#Linux-记录" class="headerlink" title="Linux 记录"></a>Linux 记录</h1><p>查看磁盘分区上可以使用的空间 df<br> 查看每个文件和目录的磁盘使用空间 du </p><p>安装hbase的时候ubuntu系统空间满了 需要扩容一下</p><p><a href="https://blog.csdn.net/toby54king/article/details/105375527">https://blog.csdn.net/toby54king/article/details/105375527</a></p><p>vim下显示行号：在命令模式下 :set nu</p><p>取消行号：在命令模式下 :set nonu</p><p>vim 搜索关键词</p><ol><li>在命令模式(按esc即可)下敲斜杆( &#x2F; )这时在状态栏（也就是屏幕左下脚）就出现了“&#x2F;”</li><li>然后输入你要<strong>查找</strong>的<strong>关键字</strong>敲回车就可以了</li><li>如果你要继续<strong>查找</strong>此<strong>关键字</strong>，敲字符n 就可以继续<strong>查找</strong>了</li><li>敲字符N（大写N）就会向前查询；</li></ol><p>查看历史命令 history </p><p>重新运行历史记录命令  !xx  </p><p>重新执行上一条指令 !!</p><h1 id="Hadoop实践"><a href="#Hadoop实践" class="headerlink" title="Hadoop实践"></a>Hadoop实践</h1><p>常见命令：</p><p>启动Hadoop：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd &#x2F;usr&#x2F;local&#x2F;hadoop.&#x2F;sbin&#x2F;start-dfs.sh #启动hadoop</code></pre><p>在HDFS中为hadoop用户创建一个用户目录：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.&#x2F;bin&#x2F;hdfs dfs -mkdir -p &#x2F;user&#x2F;hadoop</code></pre><p>注：“-p”表示如果是多级目录，则父目录和子目录一起创建，这里“&#x2F;user&#x2F;hadoop”就是一个多级目录，因此必须使用参数“-p”，否则会出错。</p><p>显示HDFS中与当前用户hadoop对应的用户目录下的内容：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.&#x2F;bin&#x2F;hdfs dfs -ls .  等价于.&#x2F;bin&#x2F;hdfs dfs -ls &#x2F;user&#x2F;hadoop</code></pre><p>列出HDFS上的所有目录：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.&#x2F;bin&#x2F;hdfs dfs -ls</code></pre><p>使用rm命令删除一个目录（不是“&#x2F;user&#x2F;hadoop&#x2F;input”目录）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.&#x2F;bin&#x2F;hdfs dfs -rm -r &#x2F;input</code></pre><p>“-r”参数表示如果删除“&#x2F;input”目录及其子目录下的所有内容，如果要删除的一个目录包含了子目录，则必须使用“-r”参数，否则会执行失败。</p><p>上传文件&#x2F;下载文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">上传到hdfs：.&#x2F;bin&#x2F;hdfs dfs -put   </code></pre><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309191839386.png" alt="image-20230904155035472"></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">下载到本地机：.&#x2F;bin&#x2F;hdfs dfs -get</code></pre><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309191839323.png" alt="image-20230904155235118"></p><p>拷贝文件   cp A  to B</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.&#x2F;bin&#x2F;hdfs dfs -cp input&#x2F;myLocalFile.txt   &#x2F;input</code></pre><h1 id="HBase"><a href="#HBase" class="headerlink" title="HBase"></a>HBase</h1><p>环境配置：<a href="https://dblab.xmu.edu.cn/blog/4252/">https://dblab.xmu.edu.cn/blog/4252/</a></p><p>三种运行模式：</p><ol><li>单机模式：在一台计算机上安装和使用HBase，不涉及数据的分布式存储</li><li>伪分布式模式：在一台计算机上模拟一个小的集群</li><li>分布模式：使用多台计算机实现物理意义上的分布式存储</li></ol><h3 id="常见命令："><a href="#常见命令：" class="headerlink" title="常见命令："></a>常见命令：</h3><p>启动HBase：首先切换目录至HBase安装目录&#x2F;usr&#x2F;local&#x2F;hbase；再启动HBase。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd &#x2F;usr&#x2F;local&#x2F;hbasebin&#x2F;start-hbase.shbin&#x2F;hbase shell</code></pre><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309191839558.png" alt="image-20230905105241907"></p><p>关闭HBase：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">bin&#x2F;stop-hbase.sh</code></pre><p>语句[export HBASE_MANAGES_ZK&#x3D;true]表示采用HBase自带的ZooKeeper管理。如果想用外部<br>ZooKeeper管理HBase,可以自行安装、配置ZooKeeper,再把该句删除。</p><p>正确运行关闭顺序：启动Hadoop -&gt; 启动HBase  -&gt; 关闭HBase -&gt;关闭Hadoop</p><h3 id="The-authenticity-of-host-‘127-0-0-1’-127-0-0-1-’-can’t-be-established"><a href="#The-authenticity-of-host-‘127-0-0-1’-127-0-0-1-’-can’t-be-established" class="headerlink" title="The authenticity of host ‘127.0.0.1’(127.0.0.1)’  can’t be established."></a>The authenticity of host ‘127.0.0.1’(127.0.0.1)’  can’t be established.</h3><p>启动Hbase的时候出现了这个问题：。。。。。</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309191839746.png" alt="image-20230905165954225"></p><p>前面的一大段报错信息和jps没有显示HQuorumPeer，网上寻找解决方案之后，确定是ssh的问题：</p><p>关闭HBase时也出现错误：</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309191839759.png" alt="image-20230905215906381"></p><p>解决方案：</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309191839411.png" alt="image-20230905214609675"></p><p>在文件末尾加上</p><pre class="line-numbers language-none"><code class="language-none">StrictHostKeyChecking noUserKnownHostsFile &#x2F;dev&#x2F;null</code></pre><p>整个文件如下：</p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309191840844.png" alt="image-20230905215351379" style="zoom:50%;" /><p>:wq保存之后再次连接  ssh localhost</p><p>终于解决了：</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309191840319.png" alt="image-20230905214700712"></p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309191840489.png" alt="image-20230905204244949"></p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309191840828.png" alt="image-20230905204340037"></p><p>进入shell界面：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">bin&#x2F;hbase shell</code></pre><p>这里启动会稍慢，需要等待一会儿</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309191840973.png" alt="image-20230905164228873"></p><p>关闭HBase也没有出现错误了（之前报 no master）</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309191840197.png" alt="image-20230905214816072"></p><h3 id="常见操作："><a href="#常见操作：" class="headerlink" title="常见操作："></a>常见操作：</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">创建表：create  &#39;student&#39;,&#39;Sname&#39;,&#39;Ssex&#39;,&#39;Sage&#39;,&#39;Sdept&#39;,&#39;course&#39;查看表的基本信息describle &#39;student&#39;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux-记录&quot;&gt;&lt;a href=&quot;#Linux-记录&quot; class=&quot;headerlink&quot; title=&quot;Linux 记录&quot;&gt;&lt;/a&gt;Linux 记录&lt;/h1&gt;&lt;p&gt;查看磁盘分区上可以使用的空间 df&lt;br&gt; 查看每个文件和目录的磁盘使用空间 du &lt;/p&gt;</summary>
      
    
    
    
    
    <category term="大数据" scheme="https://hopefuling.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
</feed>
