<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>I&#39;m Hopefuling.</title>
  
  
  <link href="https://hopefuling.github.io/atom.xml" rel="self"/>
  
  <link href="https://hopefuling.github.io/"/>
  <updated>2023-10-02T09:29:04.539Z</updated>
  <id>https://hopefuling.github.io/</id>
  
  <author>
    <name>Hopefuling</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>xv6实验</title>
    <link href="https://hopefuling.github.io/2023/10/02/xv6_lab/"/>
    <id>https://hopefuling.github.io/2023/10/02/xv6_lab/</id>
    <published>2023-10-02T08:49:03.000Z</published>
    <updated>2023-10-02T09:29:04.539Z</updated>
    
    <content type="html"><![CDATA[<hr><p>参考指导手册：</p><p>xv6中文指导手册：<a href="http://xv6.dgs.zone/">http://xv6.dgs.zone/</a></p><p>实验中文翻译：<a href="http://xv6.dgs.zone/labs/requirements/lab1.html">http://xv6.dgs.zone/labs/requirements/lab1.html</a></p><p><a href="https://th0ar.gitbooks.io/xv6-chinese/content/content/chapter0.html">https://th0ar.gitbooks.io/xv6-chinese/content/content/chapter0.html</a></p><hr><h1 id="Lab01"><a href="#Lab01" class="headerlink" title="Lab01"></a>Lab01</h1><h2 id="Lab01-0-环境配置"><a href="#Lab01-0-环境配置" class="headerlink" title="Lab01-0:环境配置"></a>Lab01-0:环境配置</h2><p>&#x3D;&#x3D;date: 2023&#x2F;9&#x2F;12&#x3D;&#x3D;</p><p>实验环境：windows11+ vmware+ Ubuntu 22.04</p><p>按官方文档配置：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&#x2F;&#x2F;安装之前先换源，再软件更新sudo apt update sudo apt install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu libglib2.0-dev libpixman-1-dev gcc-riscv64-unknown-elf&#x2F;&#x2F;查看安装是否成功：riscv64-unknown-elf-gcc   --versionqemu-system-riscv64 --versiongit clone git:&#x2F;&#x2F;g.csail.mit.edu&#x2F;xv6-labs-2022cd xv6-labs-2022git checkout util     &#x2F;&#x2F;切换到lab分支util</code></pre><p>进入&#x2F;user目录下可以看到xv6指令集的源码：</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309121445960.png" alt="image-20230912144518851"></p><p>以及kernel下的内核文件：</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309121446664.png" alt="image-20230912144611597"></p><h2 id="Lab01-1-sleep-c"><a href="#Lab01-1-sleep-c" class="headerlink" title="Lab01-1:sleep.c"></a>Lab01-1:sleep.c</h2><p>实验地址：<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/util.html">https://pdos.csail.mit.edu/6.S081/2020/labs/util.html</a> </p><p>代码参考：<a href="https://github.com/whileskies/xv6-labs-2020/blob/main/doc/Lab1-Xv6%20and%20Unix%20utilities.md">https://github.com/whileskies/xv6-labs-2020/blob/main/doc/Lab1-Xv6%20and%20Unix%20utilities.md</a></p><p>博客参考：<a href="https://ttzytt.com/2022/07/xv6_lab1_record/">https://ttzytt.com/2022/07/xv6_lab1_record/</a>   必看</p><p>检测命令参数数目，之后直接调用系统的sleep函数即可。我采用的是vim编辑器：</p><p>vim &#x2F;user&#x2F; sleep.c       进入i编辑模式：</p><p>输入以下代码：（在上面的网站有）</p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309121125824.png" align="left"  ><p>:wq 保存退出</p><p> 执行sleep命令：</p><p>先切换到xv6目录，vim 编辑Makefile，在191行处添加$U&#x2F;_sleep\，:wq保存退出：</p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309121125826.png" align="left"><p>（注：显示行号命令   :set nu ）</p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309121125907.png" align="left"><p> 完成后切换回根目录，make qemu执行启动qemu，此时执行ls命令可以看到命令集已经添加了sleep指令，输入sleep 5，执行sleep指令，执行结果是输入光标短暂停止之后，继续闪烁。</p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309121125283.png" align="left"><p> 加大sleep时间可以看的更明显。比如 sleep 20</p><h2 id="Lab01-2-pingpong-c"><a href="#Lab01-2-pingpong-c" class="headerlink" title="Lab01-2:pingpong.c"></a>Lab01-2:pingpong.c</h2><p>题目要求的顺序：</p><ul><li>父进程向子进程发送 1 字节</li><li>子进程输出 “<pid>: received ping”</li><li>子进程向父进程发送 1 字节</li><li>父进程输出     “<pid>: received pong”</li></ul><p><strong>前置知识：</strong></p><p><strong>管道</strong>（pipe）是一种最基本的进程间通信机制。管道分为 <strong>读出端</strong> 和 <strong>写入端</strong> 两个部分，进程可以向写端写入数据，也可以从读端读出数据。通过pipe系统调用，内核会为用户进程创建管道，同时返回两个文件描述符，用以描述管道的读写端。</p><p>创建管道 ：<strong>int pipe(int fd[2]);</strong> </p><p>返回值：成功，返回0，否则返回-1。参数数组包含pipe使用的两个文件的描述符。</p><p>fd[0] 将是管道读取端的fd（文件描述符）<br>fd[1] 将是管道写入端的fd</p><p> &#x2F;&#x2F; 函数调用成功返回r&#x2F;w两个文件描述符。向管道文件读写数据其实是在读写内核缓冲区。</p><p>&#x2F;&#x2F; 必须在fork()中调用pipe()，否则子进程不会继承文件描述符。</p><p>示例：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">int p[2];int ret;&#x2F;&#x2F;返回值ret &#x3D; pipe(p); &#x2F;*正常创建后，p[1]为管道写入端，p[0]为管道读出端*&#x2F; </code></pre><p> 通过文件描述符，程序可以按读写文件的形式读写管道，例如：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">int write &#x3D; write(p[1], buffer, n); &#x2F;&#x2F;p[1]为管道写入端int read &#x3D; read(p[0], buffer, n);&#x2F;&#x2F;p[0]为管道读出端</code></pre><p>进程通常只持有某个管道的读出端或者写入端，因此使用的时候需要将另一端关闭。(单管道)</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;* 子进程读管道，父进程写管道 *&#x2F;int pid &#x3D; fork();if (pid &#x3D;&#x3D; 0) &#123;  &#x2F;* 子进程 *&#x2F; &#x2F;&#x2F;fork返回0为子进程    close(p[1]); &#x2F;&#x2F; 关闭写端    ...    read(...);    ...    close(p[0]); &#x2F;&#x2F; 读取完成，关闭读端&#125; else if (pid&gt;0) &#123;  &#x2F;* 父进程 *&#x2F; &#x2F;&#x2F;fork大于0为父进程    close(p[0]); &#x2F;&#x2F; 关闭读端    ...    write(...);    ...    close(p[1]); &#x2F;&#x2F; 写入完成，关闭写端&#125;</code></pre><hr><p>那么实验的大致步骤为：</p><ol><li><p>父进程调用pipe函数创建管道，得到两个文件描述符fd[0]、fd[1]指向管道的读端和写端。</p></li><li><p>父进程调用fork创建子进程，那么子进程也有两个文件描述符指向同一管道。</p></li><li><p>父进程关闭管道读端，子进程关闭管道写端。父进程可以向管道中写入数据，子进程将管道中的数据读出。由于管道是利用环形队列实现的，数据从写端流入管道，从读端流出，这样就实现了进程间通信。</p></li></ol><p>vim  user&#x2F;pingpong.c  </p><p>实验代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &quot;kernel&#x2F;types.h&quot;#include &quot;kernel&#x2F;stat.h&quot;#include &quot;user&#x2F;user.h&quot;int main(int argc, char *argv[])&#123;  int p1[2];   int p2[2];   if (pipe(p1) &lt; 0 || pipe(p2) &lt; 0) &#123;    fprintf(2, &quot;pingpong: pipe failed\n&quot;);    exit(1);  &#125;  int pid &#x3D; fork();  if (pid &lt; 0) &#123;&#x2F;&#x2F;创建子进程失败    fprintf(2, &quot;pingpong: fork child process failed\n&quot;);    exit(1);  &#125;  char buf[2] &#x3D; &#123;0&#125;;  if (pid &gt; 0) &#123; &#x2F;&#x2F; 父进程    &#x2F;&#x2F;管道读写是单工的，读写端不可以同时开启；避免子进程写端未关闭，干扰父进程的读操作    close(p1[0]);&#x2F;&#x2F;关闭父进程的管道读出端    close(p2[1]);&#x2F;&#x2F;关闭子进程的管道写入端    write(p1[1], &quot;a&quot;, 1);    read(p2[0], buf, sizeof buf); &#x2F;&#x2F;父进程读操作    fprintf(1, &quot;%d: received pong\n&quot;, getpid());    close(p1[1]);    close(p2[0]);  &#125; else &#123; &#x2F;&#x2F; pid&#x3D;0 子进程    close(p1[1]);&#x2F;&#x2F;关闭父进程的管道写入端    close(p2[0]);&#x2F;&#x2F;关闭子进程的管道读出端    read(p1[0], buf, sizeof buf); &#x2F;&#x2F;子进程写操作    fprintf(1, &quot;%d: received ping\n&quot;, getpid());    write(p2[1], &quot;b&quot;, 1);    close(p1[0]);    close(p2[1]);  &#125;  wait(0);  exit(0);&#125;</code></pre><p>添加MakeFile之后运行测试：</p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309121216493.png" alt="image-20230912121600407"  /><p>参考资源：</p><p><a href="https://xiaoxiami.gitbook.io/linux-server/duo-jin-cheng-bian-cheng/forkhan-shu">https://xiaoxiami.gitbook.io/linux-server/duo-jin-cheng-bian-cheng/forkhan-shu</a></p><p><a href="https://zhuanlan.zhihu.com/p/415609647">https://zhuanlan.zhihu.com/p/415609647</a></p><h2 id="Lab01-3-primes-c"><a href="#Lab01-3-primes-c" class="headerlink" title="Lab01-3: primes.c"></a>Lab01-3: primes.c</h2><p>该程序的逻辑是把 2-35 之间的质数筛选出来，并在终端进行输出。约定以下：</p><p>（1） 父进程 A 生成[2-35]之间的所有数字，包括 2 和 35；<br>（2） 向 A 的子进程 B 进行输出（通过管道）；<br>（3） B 对[2-35]进行筛选，打印出第一个质数 2；<br>（4） B 把剩下的数字（通过）通过管道传递给 B 的子进程 C；<br>（5） C 打印出第二个质数，也即 3；<br>（6） 重复（4）和（5）的过程，直到 2-35 之间的质数全部在终端输出。</p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309121452233.png" alt="image-20230912145203149" style="zoom:50%;" /><p>思路：</p><p>从主进程开始，不断新建子进程，每个子进程执行一次筛选，并将使用的基（base）认为是质数（这是正确的，请思考为什么），并返回，直到全部的数都被筛去或被返回。</p><p>各个进程之间的通讯将会使用到管道。</p><p>还需要注意两点：</p><ul><li><strong>文件描述符溢出：</strong>  xv6限制fd的范围为0~15，而每次pipe()都会创建两个新的fd，如果不及时关闭不需要的fd，会导致文件描述符资源用尽。这里使用重定向到标准I&#x2F;O的方式来避免生成新的fd，首先close()关闭标准I&#x2F;O的fd，然后使用dup()复制所需的管道fd（会自动复制到序号最小的fd，即关闭的标准I&#x2F;O），随后对pipe两侧fd进行关闭（此时只会移除描述符，不会关闭实际的file对象）。</li><li><strong>pipeline关闭：</strong>  在完成素数输出后，需要依次退出pipeline上的所有进程。在退出父进程前关闭其标准输入fd，此时read()将读取到eof（值为0），此时同样关闭子进程的标准输入fd，退出进程，这样进程链上的所有进程就可以退出。</li><li>参考于：<a href="https://zhayujie.com/mit6828-lab-util.html">https://zhayujie.com/mit6828-lab-util.html</a></li></ul><p>运行测试：</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309121629185.png" alt="image-20230912162954933"></p><p>提示</p><ul><li><p>请牢记这个题目的要求是<strong>通过多线程来加速素数筛</strong>，在编写程序时要检查自己的程序是否满足并发，<strong>一定不要在父进程写入所有数字后子进程才开始处理！</strong>即使这样也能通过测试。</p></li><li><p>请小心关闭进程不需要的文件描述符，否则程序将在第一个进程达到 35 之前耗尽xv6的资源。（<strong>及时关闭管道非常重要！！！</strong>）</p></li><li><p>当一个进程读取完所有数字后，应该等到所有他的子进程终止才能终止，从而避免产生僵尸进程。（善用<code>ctrl+p</code>）</p></li><li><p>当一个管道的写端被关闭时，对读端进行<code>read</code>会返回0。</p></li><li><p>写入所有数字后<strong>再写入一个0来表示写入完毕</strong>，否则子进程无法知道父进程是否写入完毕。采取这种做法是因为执行了<code>fork</code>后父进程才关闭管道写端，子进程并不能感应到管道写端已经关闭了。</p></li><li><p>参考于：<a href="https://zhuanlan.zhihu.com/p/547418924">https://zhuanlan.zhihu.com/p/547418924</a></p></li></ul><p>前置知识：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;*1、write()函数： ssize_t write(int fd,const void*buf,size_t count);参数说明：  fd:是文件描述符（write所对应的是写，即就是1）  buf:通常是一个字符串，需要写入的字符串  count：是每次写入的字节数返回值：  成功：返回写入的字节数  失败：返回-1并设置errno2、read()函数:  ssize_t read(int fd,void*buf,size_t count)      功能:  用于从文件描述符对应的文件读取数据（从打开的设备或文件中读取数据）参数说明:fd:      是文件描述符buf:     为读出数据的缓冲区；count:   为每次读取的字节数（是请求读取的字节数，读上来的数据保         存在缓冲区buf中，同时文件的当前读写位置向后移）返回值： 成功：返回读出的字节数 失败：返回-1，并设置errno，如果在调用read之前到达文件末尾，则这次read返回0    *&#x2F;  &#x2F;&#x2F;示例：int main()&#123;   const char*msg&#x3D;&quot;hello\n&quot;;   int len &#x3D; strlen(msg);   write(1,msg,len);&#x2F;&#x2F;write所对应的文件描述符为1   char buf[1024]&#x3D;&#123;0&#125;;   read(0,buf,len);&#x2F;&#x2F;read所对应的文件描述符为0   return 0;&#125;</code></pre><p>首先打开提示给出的链接，阅读并观察上面给出的图。由图可见，首先将数字全部输入到最左边的管道，然后第一个进程打印出输入管道的第一个数 2 ，并将管道中所有 2 的倍数的数剔除。接着把剔除后的所有数字输入到右边的管道，然后第二个进程打印出从第一个进程中传入管道的第一个数 3 ，并将管道中所有 3 的倍数的数剔除。接着重复以上过程，最终打印出来的数都为素数。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &quot;kernel&#x2F;types.h&quot;#include &quot;user&#x2F;user.h&quot;void process(int p[])&#123;    close(p[1]);&#x2F;&#x2F;关闭向管道写端口    int prime;    if (read(p[0], &amp;prime, 4) &gt; 0) &#123;         fprintf(1, &quot;prime %d\n&quot;, prime);        int p2[2];        pipe(p2);        if (fork() &gt; 0) &#123;&#x2F;&#x2F;parent父进程            close(p2[0]);&#x2F;&#x2F;关闭读端口            int i;            while(read(p[0], &amp;i, 4) &gt; 0) &#123;                if (i % prime !&#x3D; 0) &#123; &#x2F;&#x2F;筛出能被prime整除的数                    write(p2[1], &amp;i, 4);&#x2F;&#x2F;剩下不能被整除的数写进管道                &#125;            &#125;            close(p2[1]);            wait(0);        &#125; else &#123; &#x2F;&#x2F;子进程递归            close(p[0]);            process(p2);        &#125;    &#125;&#125;int main(int argc, char* argv[])&#123;    int p[2];    pipe(p);    int pid &#x3D; fork();    if (pid &gt; 0) &#123; &#x2F;&#x2F; parent 父进程        close(p[0]);        fprintf(1, &quot;prime 2\n&quot;);        for (int i &#x3D; 3; i &lt;&#x3D; 35; ++i) &#123;            if (i % 2 !&#x3D; 0) &#123; &#x2F;&#x2F;不能被2整除的数写进管道                write(p[1], &amp;i, 4);            &#125;        &#125;        close(p[1]);  &#x2F;&#x2F;关闭写端口        wait(0);    &#125; else &#123;&#x2F;&#x2F;子进程 递归操作        process(p);    &#125;    exit(0);&#125;</code></pre><h2 id="Lab01-4-find-c"><a href="#Lab01-4-find-c" class="headerlink" title="Lab01-4:find.c"></a>Lab01-4:find.c</h2><p>编写一个简单版本的 UNIX 查找程序：在目录树中查找名称与字符串匹配的所有文件。</p><p><strong>提示：</strong></p><ul><li>查看 user&#x2F;ls.c 以了解如何读取目录。</li><li>使用递归允许查找下降到子目录。</li><li>不要递归到“。” 和 ”..”。</li></ul><p>从ls.c稍加修改即可：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F;ls.c#include &quot;kernel&#x2F;types.h&quot;#include &quot;kernel&#x2F;stat.h&quot;#include &quot;user&#x2F;user.h&quot;#include &quot;kernel&#x2F;fs.h&quot;&#x2F;&#x2F; linux目录的形式是 &#x2F;bin  前面有个&#x2F;char *fmtname(char *path)&#123;    static char buf[DIRSIZ + 1];    char *p;    &#x2F;&#x2F; Find first character after last slash.    for (p &#x3D; path + strlen(path); p &gt;&#x3D; path &amp;&amp; *p !&#x3D; &#39;&#x2F;&#39;; p--)        ;    p++;    &#x2F;&#x2F; Return blank-padded name.    if (strlen(p) &gt;&#x3D; DIRSIZ)        return p;    memmove(buf, p, strlen(p));    memset(buf + strlen(p), &#39; &#39;, DIRSIZ - strlen(p));    return buf;&#125;void ls(char *path)&#123;    char buf[512], *p;    int fd;    struct dirent de; &#x2F;&#x2F;这个指的是目录项这一结构体（在kernel&#x2F;fs.h中定义），其实目录也是一种文件，里面就是存放了一系列的目录项    struct stat st;   &#x2F;&#x2F;这个指的是文件的统计信息（在kernel&#x2F;stat.h中定义），包含文件类型（目录或文件）&#x2F;inode&#x2F;文件引用nlink&#x2F;文件大小&#x2F;存放fs的disk dev    if ((fd &#x3D; open(path, 0)) &lt; 0)    &#123; &#x2F;&#x2F;打开文件，第二个参数指示的是打开方式，0代表的是O_RDONLY只读的形式。返回值是file descriptor &gt;&#x3D;0，&lt;0说明open失败        fprintf(2, &quot;ls: cannot open %s\n&quot;, path);        return;    &#125;    if (fstat(fd, &amp;st) &lt; 0)    &#123; &#x2F;&#x2F; fstat的含义同open类似        fprintf(2, &quot;ls: cannot stat %s\n&quot;, path);        close(fd);        return;    &#125;    switch (st.type)    &#123;&#x2F;&#x2F; switch 中主要是两个逻辑，一个是文件如何处理，一个是目录怎么处理    case T_FILE:&#x2F;&#x2F;如果是文件，直接打印信息        printf(&quot;%s %d %d %l\n&quot;, fmtname(path), st.type, st.ino, st.size);            &#x2F;&#x2F; st.type中三个值分别是(&#123;1:目录,2:文件,3:console&#125;) fmtname返回值就是文件名称        break;    case T_DIR:        if (strlen(path) + 1 + DIRSIZ + 1 &gt; sizeof buf)        &#123; &#x2F;&#x2F;检查缓存有没有溢出            printf(&quot;ls: path too long\n&quot;);            break;        &#125;        strcpy(buf, path);        p &#x3D; buf + strlen(buf);        *p++ &#x3D; &#39;&#x2F;&#39;; &#x2F;&#x2F;拼接字符串，以路径名访问这个目录里面的内容        while (read(fd, &amp;de, sizeof(de)) &#x3D;&#x3D; sizeof(de))        &#123;&#x2F;&#x2F;访问目录内容。每次read只是read一个de的大小（也就是一个目录项），只有read到最后一个目录项的下一次read才会返回0，也就不满足while循环条件退出循环，            if (de.inum &#x3D;&#x3D; 0) &#x2F;&#x2F;此文件夹无文件，continue操作后进行下一次read                continue;            memmove(p, de.name, DIRSIZ);             &#x2F;&#x2F; memmove为内存之间的迁移，在ls.c里面的意思就是将de.name的内容移动到p指向的指针中            p[DIRSIZ] &#x3D; 0;            if (stat(buf, &amp;st) &lt; 0)            &#123;                printf(&quot;ls: cannot stat %s\n&quot;, buf);                continue;            &#125;            printf(&quot;%s %d %d %d\n&quot;, fmtname(buf), st.type, st.ino, st.size);        &#125;        break;    &#125;    close(fd);&#125;int main(int argc, char *argv[])&#123;    int i;    if (argc &lt; 2)    &#123;        ls(&quot;.&quot;); &#x2F;&#x2F;默认展示当前工作目录的所有文件        exit(0);    &#125;    for (i &#x3D; 1; i &lt; argc; i++)        ls(argv[i]); &#x2F;&#x2F; ls 和我们熟知的linux的ls是不太相同的，xv6的ls是可以接受多个目录作为参数的    exit(0);&#125;&#x2F;&#x2F; kernel&#x2F;fs.hstruct dirent&#123;    ushort inum;    char name[DIRSIZ];&#125;;&#x2F;&#x2F; kernel&#x2F;stat.h#define T_DIR 1    &#x2F;&#x2F; Directory#define T_FILE 2   &#x2F;&#x2F; File#define T_DEVICE 3 &#x2F;&#x2F; Devicestruct stat&#123;    int dev;     &#x2F;&#x2F; File system&#39;s disk device    uint ino;    &#x2F;&#x2F; Inode number    short type;  &#x2F;&#x2F; Type of file    short nlink; &#x2F;&#x2F; Number of links to file    uint64 size; &#x2F;&#x2F; Size of file in bytes&#125;;</code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &quot;kernel&#x2F;types.h&quot;#include &quot;kernel&#x2F;stat.h&quot;#include &quot;user&#x2F;user.h&quot;#include &quot;kernel&#x2F;fs.h&quot; char*fmtname(char *path) &#x2F;&#x2F;格式化名字，把名字变成前面没有左斜杠&#x2F;，仅仅保存文件名&#123;  static char buf[DIRSIZ+1];  char *p;   &#x2F;&#x2F; Find first character after last slash.  for(p&#x3D;path+strlen(path); p &gt;&#x3D; path &amp;&amp; *p !&#x3D; &#39;&#x2F;&#39;; p--)    ;  p++;   &#x2F;&#x2F; Return blank-padded name.  memmove(buf, p, strlen(p) + 1);  return buf;&#125; voidfind(char *path, char* findName)&#123;  char buf[512], *p;  int fd;  struct dirent de;  struct stat st;   if((fd &#x3D; open(path, 0)) &lt; 0)&#123;    fprintf(2, &quot;find: cannot open %s\n&quot;, path);    return;  &#125;   if(fstat(fd, &amp;st) &lt; 0)&#123;    fprintf(2, &quot;find: cannot stat %s\n&quot;, path);    close(fd);    return;  &#125;   switch(st.type)&#123;  case T_FILE:&#x2F;&#x2F; 如果是文件类型，那么比较，文件名是否匹配，匹配则输出    if(strcmp(fmtname(path), findName) &#x3D;&#x3D; 0)      printf(&quot;%s\n&quot;, path);    break;  case T_DIR:&#x2F;&#x2F;如果是目录则递归去查找    if(strlen(path) + 1 + DIRSIZ + 1 &gt; sizeof buf)&#123;&#x2F;&#x2F;检查缓存有没有溢出      printf(&quot;find: path too long\n&quot;);      break;    &#125;    strcpy(buf, path);    p &#x3D; buf+strlen(buf);    &#x2F;&#x2F;拼接字符串，以路径名访问这个目录里面的内容    *p++ &#x3D; &#39;&#x2F;&#39;;&#x2F;&#x2F;buf是一个绝对路径，p是一个文件名，并通过加&quot;&#x2F;&quot;前缀拼接在buf的后面    while(read(fd, &amp;de, sizeof(de)) &#x3D;&#x3D; sizeof(de))&#123;      if(de.inum &#x3D;&#x3D; 0) &#123;&#x2F;&#x2F;此文件夹无文件，continue操作后进行下一次read         continue;        &#125;      memmove(p, de.name, DIRSIZ);&#x2F;&#x2F;memmove, 把de.name信息复制p,其中de.name是char name[255],代表文件名      p[strlen(de.name)] &#x3D; 0; &#x2F;&#x2F; 设置文件名结束符        if(strcmp(de.name, &quot;.&quot;) &#x3D;&#x3D; 0 || strcmp(de.name, &quot;..&quot;) &#x3D;&#x3D; 0) &#123;                continue;        &#125;        find(buf, findName);    &#125;    break;  &#125;  close(fd);&#125; intmain(int argc, char *argv[])&#123;   if(argc &lt; 3)&#123;        printf(&quot;error argc num&quot;);    exit(0);  &#125;  find(argv[1], argv[2]);  exit(0);&#125;</code></pre><h2 id="Lab01心得"><a href="#Lab01心得" class="headerlink" title="Lab01心得"></a>Lab01心得</h2><p>上学期学习操作系统的时候跟着学了一小段的xv6，从刚开始的配置环境配了大几天（早知道还得是用docker），之后换了镜像，这学期居然课程项目还是这个xv6（悲），。。但是在这么折腾配置环境的锻炼下，这次重新配置环境非常快（同时也对我学习其他linux环境下的软件等都很有帮助，遇到问题也会积极的去排查）。</p><p>这几个实验上学期都做过了，这次重新做，顺便整理了笔记，也把每一个lab都看懂了，之前饶有兴趣看了xv6下的user还要kernel的源码（肯定看的不多而且看不太懂），在这之前会以为shell是个很深的东西，实际上也就是一个个命令文件以及内核文件组成的，可以随意自定义操作命令，也可以自定义shell终端页面：</p><p>蛮有意思的。</p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309131350576.png" alt="image-20230913135024489" style="zoom: 50%;" /><h1 id="Lab02-1-system-call"><a href="#Lab02-1-system-call" class="headerlink" title="Lab02-1 system call"></a>Lab02-1 system call</h1><p>Lab02-1:system call</p><p>实验地址：<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/syscall.html">https://pdos.csail.mit.edu/6.S081/2020/labs/syscall.html</a></p><p>前置知识：gdb调试    <a href="https://www.chens.life/posts/mit-xv6-lab2/">https://www.chens.life/posts/mit-xv6-lab2/</a>     </p><p><strong>配合别人的博客笔记一起食用：</strong><a href="https://ttzytt.com/2022/07/xv6_lab2_record/index.html">https://ttzytt.com/2022/07/xv6_lab2_record/index.html</a>     （必看！！）</p><p><a href="https://miaochenlu.github.io/2020/12/16/xv6-lab2/">https://miaochenlu.github.io/2020/12/16/xv6-lab2/</a></p><hr><p>Lab要求：实现一个追踪特定进程系统调用的系统调用，叫做 trace。 利用这个 trace，在执行其他进程的时候，那么 trace 就会以特定格式输出这个进程调用过的系统调用。其中，有一个 mask 作为参数，指定有哪些调用需要被追踪。</p><p>实验主页给出了trace执行的四个例子：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ trace 32 grep hello README3: syscall read -&gt; 10233: syscall read -&gt; 9663: syscall read -&gt; 703: syscall read -&gt; 0$#在这里的grep就是mask参数，表示只需要追踪grep#打印内容仅打印了grep跟踪read系统调用。32&#x3D;2^5，“The 32 is 1&lt;&lt;SYS_read.”，也就是说执行这行命令，只跟踪系统调用号为5的执行过程，看到后面的syacall.h就会发现SYS_read&#x3D;5,也就是read的这个调用号就是5，所以输出只打印出了read的调用过程。--------------------------------------------$ trace 2147483647 grep hello README4: syscall trace -&gt; 04: syscall exec -&gt; 34: syscall open -&gt; 34: syscall read -&gt; 10234: syscall read -&gt; 9664: syscall read -&gt; 704: syscall read -&gt; 04: syscall close -&gt; 0$#2147483647即01111111111111111111111111111111，其低31为全部为 1 ，就证明 30号（包括30号）以下的系统调用都需要跟踪）#2147483647这是int整型的最大值，足以包括所有的系统调用号，因此这是打印出执行命令整个过程的所有的系统调用。--------------------------------------------$ grep hello README$#没调用trace，不打印调用过程的任何内容，只执行命令。--------------------------------------------$ trace 2 usertests forkforkforkusertests starting         #表示表示 usertests 进程已开始执行test forkforkfork: 407: syscall fork -&gt; 408  #表示进程 407 执行了系统调用 fork，创建了一个子进程 408408: syscall fork -&gt; 409  #表示进程 408 执行了系统调用 fork，创建了一个子进程 409409: syscall fork -&gt; 410  #....类似上面。。。410: syscall fork -&gt; 411409: syscall fork -&gt; 412410: syscall fork -&gt; 413409: syscall fork -&gt; 414411: syscall fork -&gt; 415...#2&#x3D;2^1,也就是传入的系统调用号为1，找到syscall.h中对应的SYS_fork&#x3D;1,因此这行命令表示使用 trace 命令对 usertests forkforkfork 程序进行详细的系统调用追踪。forkforkfork是系统没有的，自定义的测试命令，这个命令不断的生成子进程，每个子进程中都会再次调用 fork，从而创建更多的子进程，形成进程树的结构。</code></pre><p>附：xv6的系统调用（ 查看 kernel&#x2F;syscall.h）</p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309151905003.png" alt="image-20230915190519923" style="zoom: 60%;" align="left" /><hr><p>看完几篇博客，略懂了系统调用的大致过程。</p><p>首先，用户态的系统调用函数被声明（只是声明，没有实现）在 <code>user/user.h</code> 中。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F; system callsint fork(void);int exit(int) __attribute__((noreturn));int wait(int*);int pipe(int*);int write(int, const void*, int);int read(int, void*, int);int close(int);int kill(int);int exec(char*, char**);...char* sbrk(int);int sleep(int);int uptime(void);</code></pre><p>上面的函数声明在<code>user/usys.S</code>这个文件中用汇编语言实现的：</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">fork:#include &quot;kernel&#x2F;syscall.h&quot;.global fork li a7, SYS_fork ecall ret.global exitexit: li a7, SYS_exit ecall ret.global wait……</code></pre><p>举个例子讲解一下，比如fork的实现</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">fork:#include &quot;kernel&#x2F;syscall.h&quot;.global fork li a7, SYS_fork   ecall ret</code></pre><p>上面的 <code>li a7, SYS_fork</code> 中的 <code>SYS_fork</code> 就是一个立即数。它被定义在 <code>kernel/syscall.h</code> 中，所以汇编的开头要 <code>#include &quot;kernel/syscall.h&quot;</code>。这行命令就是把这个立即数 li（load immediate）到a7寄存器。</p><p>附：kernel&#x2F;syscall.h部分内容</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F;kernel&#x2F;syscall.h&#x2F;&#x2F; System call numbers#define SYS_fork    1#define SYS_exit    2#define SYS_wait    3#define SYS_pipe    4#define SYS_read    5#define SYS_kill    6...</code></pre><p>可以看到，这个文件定义了不同系统调用的编号，把这个立即数加载进寄存器，这样进入内核之后，我们就知道之前调用的是哪个系统调用。</p><p>汇编的下一行是<code>ecall</code>,作用是跳到内核栈地址，同时保存现场，在结束的时候可以顺利的恢复到进入内核之前的状态。</p><p>进入内核之后，会先进入一个内核的处理函数，即<code>syscall()</code>;</p><p>文件在kernel&#x2F;syscall.c ：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">static uint64 (*syscalls[])(void) &#x3D; &#123;    [SYS_fork] sys_fork,   [SYS_exit] sys_exit,     [SYS_wait] sys_wait,    [SYS_pipe] sys_pipe,   [SYS_read] sys_read,     [SYS_kill] sys_kill,    [SYS_exec] sys_exec,   [SYS_fstat] sys_fstat,   [SYS_chdir] sys_chdir,    [SYS_dup] sys_dup,     [SYS_getpid] sys_getpid, [SYS_sbrk] sys_sbrk,    [SYS_sleep] sys_sleep, [SYS_uptime] sys_uptime, [SYS_open] sys_open,    [SYS_write] sys_write, [SYS_mknod] sys_mknod,   [SYS_unlink] sys_unlink,    [SYS_link] sys_link,   [SYS_mkdir] sys_mkdir,   [SYS_close] sys_close,    [SYS_trace] sys_trace, [SYS_sysinfo] sys_sysinfo,&#125;; &#x2F;&#x2F; 指向函数的指针的数组voidsyscall(void)&#123;    int num;    struct proc *p &#x3D; myproc();    num &#x3D; p-&gt;trapframe-&gt;a7;    if (num &gt; 0 &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;        p-&gt;trapframe-&gt;a0 &#x3D; syscalls[num]();    &#125; else &#123;        printf(&quot;%d %s: unknown sys call %d\n&quot;, p-&gt;pid, p-&gt;name, num);        p-&gt;trapframe-&gt;a0 &#x3D; -1;    &#125;&#125;</code></pre><p>其中：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">num &#x3D; p-&gt;trapframe-&gt;a7;  if (num &gt; 0 &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</code></pre><p>看syscall中的这两行，首先p-&gt;trapframe-&gt;a7是去读取寄存器a7上的内容，赋值给num，即系统调用号。</p><p>然后在if语句中syscalls[num]就会跳到指向函数的数组指针，就可以读取到这个相对应的函数；</p><p>（比如a7上面的数是1时，对应的就是SYS_fork，读取到的就是 [SYS_fork] sys_fork）</p><p><code>syscalls</code> 数组存储了所有的系统调用函数，每个系统调用对应一个数组元素。当用户进程发起系统调用时，内核会通过系统调用号获取到相应的系统调用函数，然后执行该函数。</p><p>（这里的 <code>[SYS_fork] sys_fork</code> 是 C 语言数组的一个语法，表示以方括号内的值作为元素下标。比如 int arr[] &#x3D; {[3] 2333, [6] 6666}代表 arr 的下标 3 的元素为 2333，下标 6 的元素为 6666，其他元素填充 0 的数组。（该语法在 C++ 中已不可用））</p><p>这些系统服务的具体实现都不在这个文件中，在 <code>kernel/sysproc.c</code> 中。 部分内容如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">...&#x2F;**sys_exit 函数：该函数用于用户进程退出操作。它首先通过 argint 函数从用户进程传递的参数中获取一个整数值 n，然后调用 exit(n) 函数，将 n 作为退出状态码传递给当前进程。最后，它返回 0，但实际上由于执行了 exit 函数，该语句永远不会被执行。*&#x2F;uint64sys_exit(void)&#123;  int n;  argint(0, &amp;n);  exit(n);  return 0;  &#x2F;&#x2F; not reached&#125;&#x2F;**sys_getpid 函数：该函数用于获取当前进程的进程ID（PID）。它通过调用 myproc() 函数获取当前进程的指针，并从中取得进程ID（pid 成员变量）。最后，它将进程ID作为返回值返回给用户进程。*&#x2F;uint64sys_getpid(void)&#123;  return myproc()-&gt;pid;&#125;&#x2F;**sys_fork 函数：该函数用于创建一个子进程。它调用 fork() 函数来实现进程的复制，创建出一个新的子进程，并使得父子进程都能够继续执行不同的代码。最后，它将 fork 函数的返回值（子进程的进程ID or 0）作为返回值返回给用户进程。*&#x2F;uint64sys_fork(void)&#123;  return fork();&#125;...</code></pre><hr><p>重新回顾一下刚才的语句：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F;syscall.c&#x2F;syscall()num &#x3D; p-&gt;trapframe-&gt;a7;if (num &gt; 0 &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;        p-&gt;trapframe-&gt;a0 &#x3D; syscalls[num]();    &#125;</code></pre><p>在 xv6 中，当用户进程陷入内核态（即发起系统调用）时，内核将 <code>trapframe</code> 结构体指针 <code>p-&gt;trapframe</code> 中存储的寄存器状态保存下来，并将相应的寄存器设置为内核栈的地址，以便内核能够在内核态下使用这些寄存器。然后，内核检查系统调用号是否合法，如果合法，则获取到对应的系统调用函数并执行该函数，最后将返回值存储到 <code>a0</code> 寄存器中。</p><p>在这段代码中，<code>num</code> 是用户进程传递的系统调用号，如果该系统调用号合法，则执行对应的系统调用函数。<code>syscalls[num]()</code> 调用该系统调用函数，并将其返回值存储到 <code>a0</code> 寄存器中，以便用户进程可以读取该返回值。p-&gt;trapframe-&gt;a0 &#x3D; syscalls[num] ，系统调用的返回值会在返回用户态时，被赋到 a0 寄存器上。总之，<code>p-&gt;trapframe-&gt;a0 = syscalls[num]();</code> 这一行代码是执行系统调用函数并将其返回值存储到 <code>a0</code> 寄存器中，以便用户进程进行后续处理。</p><p>这个返回值示例有：</p><ol><li>成功执行：如果系统调用成功执行，并且不需要返回其他信息，系统调用函数通常会返回一个非负整数，表示成功执行的标志。</li><li>错误码：如果系统调用执行失败，系统调用函数可能返回一个负数，表示错误码。通过检查返回值的负号和绝对值，可以确定发生了哪种类型的错误，并采取相应的处理措施。</li><li>数据传输：某些系统调用（例如读取文件、发送数据等）可能会返回实际读取或写入的字节数，以便用户进程知道发生了多少数据传输。</li></ol><p>结束系统调用：</p><p>回顾上面提到的汇编语言：</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">exit: li a7, SYS_exit ecall ret    .global wait</code></pre><p>结束系统调用的是通过 <code>ret</code> 汇编指令实现。在系统调用函数末尾，会使用 <code>ret</code> 指令将控制权返回给调用系统调用的用户进程。</p><p>具体的步骤如下：</p><ol><li>系统调用函数执行完毕后，将返回值存储到 <code>a0</code> 寄存器中，以便用户进程读取。</li><li>使用 <code>ret</code> 指令将控制权返回给用户进程。这将导致处理器从内核态切换到用户态，并恢复用户进程之前保存的状态。</li></ol><p>当用户进程从系统调用返回到用户态后，可以继续执行后续的用户代码。</p><p>到此，整个系统调用的过程完成。</p><hr><p>下面着手做实验：</p><p>实验步骤</p><p>1、先切换到syscalll分支：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">git fetchgit checkout syscall</code></pre><p>再次进入&#x2F;user&#x2F;即可看到新增了trace.c。vim查看：</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309152107619.png" alt="image-20230915210713497"></p><p>2、确保正确编译trace.c</p><p>直接添加$U_&#x2F;trace\到Makefile，再执行编译后发现编译失败。</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309152117055.png" alt="image-20230915211726993"></p><p>课程主页也详细说明了操作步骤：</p><p>Some hints:  </p><ul><li><p>Add <code>$U/_trace</code> to UPROGS in Makefile            添加$U&#x2F;_trace</p></li><li><p>Run make qemu and you will see that the compiler cannot compile <code>user/trace.c</code>, because the user-space stubs for the system call don’t exist yet:   下面是需要更改的文件：</p><p><strong>add a prototype for the system call to <code>user/user.h</code>, a stub to <code>user/usys.pl</code>, and a syscall number to <code>kernel/syscall.h</code>.  The Makefile invokes the perl script <code>user/usys.pl</code>, which produces <code>user/usys.S</code>,  the actual system call stubs, which use the RISC-V <code>ecall</code> instruction to transition to the kernel. Once you fix the compilation issues,  run trace 32 grep hello README; it will fail because you haven’t implemented the system call in the kernel yet.</strong>        </p></li><li><p>Add a <code>sys_trace()</code> function in <code>kernel/sysproc.c</code> that implements the new system call by remembering its argument in a new variable in the <code>proc</code> structure (see <code>kernel/proc.h</code>). The functions to retrieve system call arguments from user space are in <code>kernel/syscall.c</code>, and you can see examples        of their use in <code>kernel/sysproc.c</code>.   </p></li><li><p>Modify <code>fork()</code> (see <code>kernel/proc.c</code>) to copy    the trace mask from the parent to the child process. </p></li><li><p>Modify the <code>syscall()</code> function in <code>kernel/syscall.c</code> to print the trace output. You will need to add an array of syscall names to index into.</p></li></ul><hr><p>因此这步要做的就是将trace这个命令加载到系统调用，添加一些内容到一些文件里面去。</p><p>首先是在用户态的 <code>user/user.h</code> 中申明一下，使得用户能通过调用这个接口去调用汇编代码，从而进入内核：</p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309251727715.png" alt="image-20230915212348816" style="zoom:67%;" /><p>新增在了第25行，接受一个参数为mask，即系统调用号。</p><p>如前文所讲，我们需要使用汇编去实现这个跳转函数。不过，这个汇编是 perl 的脚本自动生成的，所以需要去更改这个脚本（<code>user/usys.pl</code>）。</p><p>vim进入usys.pl，并在最后新增：entry(“trace”);   </p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309251727213.png" alt="image-20230915212714998"></p><p>（注：之后我们 make qemu 的时候，在脚本中新加的这个 entry 就会在 user&#x2F;usys.S 中输出：）</p><pre class="line-numbers language-nasm" data-language="nasm"><code class="language-nasm">.global tracetrace: li a7, SYS_trace ecall ret</code></pre><p>把SYS_trace这个系统调用号放入寄存器a7，然后ecall进入内核模式。</p><p>到此为止已经完成了在用户态的注册。接下来需要在内核中注册。现在我们需要在 <code>kernel/syscall.h</code> 给这个新的调用注册一个调用号，这样才能通过调用号找到函数。</p><p>vim syscall.h </p><p>在最后添加： #define SYS_trace  22</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309152129423.png" alt="image-20230915212920365"></p><p>然后，就像之前介绍的，内核中的中转函数 <code>syscall()</code> 需要通过一个函数指针数组来查找需要调用的函数，所以我们需要去在这个数组中新加一个元素，并且申明一下这个 trace 函数。</p><p>vim进入&#x2F;kernel&#x2F;syscall.c：</p><p>更改在104行以及130行：extern uint64 sys_trace(void);              [SYS_trace] sys_trace, </p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309152132936.png" alt="image-20230915213251819"></p><p>这里 <code>[SYS_trace] sys_trace</code> 是 C 语言数组的一个语法，表示以方括号内的值作为元素下标。比如 <code>int arr[] = &#123;[3] 2333, [6] 6666&#125;</code> 代表 arr 的下标 3 的元素为 2333，下标 6 的元素为 6666，其他元素填充 0 的数组。（该语法在 C++ 中已不可用）</p><hr><p>如前文所讲，像 extern uint64 sys_trace(void); 这样的申明是在 kernel&#x2F;syscall.c 中的，而实现在 kernel&#x2F;sysproc.c 中，我们需要到这个文件中随便添加一个实现（具体的实现在下文讲）。</p><p>注意在这里只是添加了测试代码，用于测试trace是否能正确编译。具体实现在后面还会写到。</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309152213277.png" alt="image-20230915221338187"></p><p>在最后添加上面的代码。保存退出，再重新make qemu，就可以正常编译了。</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309152215059.png" alt="image-20230915221550839"></p><p>测试一下trace命令，trace 32 grep hello README，看到hello from trace 即<strong>代表成功</strong>。（是不是很眼熟，就是上面sys_trace函数的printf）</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309152216021.png" alt="image-20230915221645821"></p><p>ctrl a  x 退出xv6</p><hr><p><strong>hh刚刚只是在实现trace命令能够编译，但还没有实现它的追踪功能。。。@__@</strong></p><hr><p><strong>接下来针对trace的追踪功能进行实现。</strong></p><p>trace追踪功能，想要了解使用了哪些系统调用，其实可以直接在系统调用的中转函数中做一些手脚，因为用户程序想要使用任何的系统服务都需要经过这个函数。那么就可以直接在这个函数中输出 trace 的信息了。</p><p>但是可能同时有很多个进程都在使用系统调用，而直接在 <code>syscall()</code> 函数中输出的话，就不只是输出一个进程使用的系统调用了。</p><p>而且直接输出的话也不符合 lab 中对 mask 的要求（也就是指定输出哪些系统调用）。</p><p>所以我们必须要有一种方法来确定当前的进程是否希望 trace，如果希望，那是希望 trace 哪些系统调用（也就是 mask）。要达到这个要求我们可以直接去给描述进程的结构体加一个 mask 属性。而定义进程的结构体就是 <code>struct proc</code>，在 <code>kernel/proc.h</code> 这个文件中：</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309152224830.png" alt="image-20230915222405713"></p><p>在最后添加上面的代码  int  trace_mask。</p><p>这样，在中转函数 <code>syscall()</code> 中，我们只需要检测当前进入内核的这个进程的 <code>trace_mask</code> 就行了。如果发现这个进程希望追踪现在它调用的这个系统调用，我们就可以直接输出了。这样一来，就不会随便碰到一个进程就输出信息了。</p><p>下面是修改过的 <code>syscall()</code> 函数，在 <code>kernel/syscall.c</code> 中。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">const static *syscall_names[] &#x3D; &#123;  &quot;fork&quot;, &quot;exit&quot;, &quot;wait&quot;, &quot;pipe&quot;, &quot;read&quot;, &quot;kill&quot;, &quot;exec&quot;, &quot;fstat&quot;, &quot;chdir&quot;, &quot;dup&quot;,  &quot;getpid&quot;, &quot;sbrk&quot;, &quot;sleep&quot;, &quot;uptime&quot;, &quot;open&quot;, &quot;write&quot;, &quot;mknod&quot;, &quot;unlink&quot;, &quot;link&quot;,  &quot;mkdir&quot;, &quot;close&quot;, &quot;trace&quot;, &quot;sysinfo&quot;&#125;;voidsyscall(void)&#123;    int num;    struct proc *p &#x3D; myproc();  &#x2F;&#x2F; myproc() 会给出当前调用系统调用的进程    num &#x3D; p-&gt;trapframe-&gt;a7;     &#x2F;&#x2F; 当前进程希望调用的系统调用    if (num &gt; 0 &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;        p-&gt;trapframe-&gt;a0 &#x3D; syscalls[num](); &#x2F;&#x2F; 通过 num 找到需要调用哪个函数        &#x2F;&#x2F; 这个 a0 储存了系统调用的返回值        int trace_mask &#x3D; p-&gt;trace_mask;     &#x2F;&#x2F; 检查这个进程的 trace mask        if ((trace_mask &gt;&gt; num) &amp; 1) &#123;      &#x2F;&#x2F; 如果当前这个系统调用是进程希望追踪的，那就输出          &#x2F;&#x2F; 3: syscall read -&gt; 1023 是 lab 中要求的格式，所以我们也按照这个格式输出          &#x2F;&#x2F; 这里的 3 是进程号，read 是调用的系统调用的名字，1023 是调用过后的返回值。          printf(&quot;%d: syscall %s -&gt; %d\n&quot;, p-&gt;pid, syscall_names[num - 1], p-&gt;trapframe-&gt;a0);        &#125;    &#125; else &#123;        printf(&quot;%d %s: unknown sys call %d\n&quot;, p-&gt;pid, p-&gt;name, num);        p-&gt;trapframe-&gt;a0 &#x3D; -1;    &#125;&#125;</code></pre><p>上面代码，新增了syscall_names[]数组，再对syscall函数进行了修改；（复制粘贴失效时重启虚拟机即可解决）</p><p>修改之后如下：（新增syscall_names[]数组，还有151-153行）</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309152248588.png" alt="image-20230915224756479"></p><p>不过，每个进程的 <code>trace_mask</code> 也不是凭空出现的，只有调用了 trace 这个系统调用，我们才会给进程增加一个 <code>trace_mask</code>。</p><p>所以肯定不能像刚才那样在实现 <code>sys_trace()</code> 时，直接输出一个 hello from trace\texttt{hello from trace}hello from trace。</p><p>下面就是修改后的 <code>sys_trace</code> 的实现。</p><p>vim  sysproc.c    修改之前的代码，如下：</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309152345706.png" alt="image-20230915234534627"></p><p>注意这里：：不要按网上的教程写成 if(argint(0, &amp;mask)) &lt; 0)。。。后面报错找答案搞了半个小时，问了gpt才知道。这个argint返回值是void，不能进行条件判断。所以要单独写出来。</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309152350163.png" alt="image-20230915235008058"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">uint64 sys_trace()&#123;  int mask;  argint(0, &amp;mask)  &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;！！！！！！！！！！！！！！  if(mask) &lt; 0)&#123;    &#x2F;&#x2F;从用户态读取第 0 个 32 位的数据    return - 1;  &#125;  struct proc *cur_proc &#x3D; myproc(); &#x2F;&#x2F; 进行系统调用的这个进程  cur_proc-&gt;trace_mask &#x3D; mask;  return 0;&#125;</code></pre><p><em>本质上很简单，我们在用户态调用 <code>trace()</code> 时，会传进去一个 <code>mask</code>，而现在这个系统调用实际上就是把传进来的这个 mask 赋值到当前的 <code>struct proc</code> 上。这样之后经过中转函数时，就可以知道要追踪哪些系统调用了。</em></p><p><em>注意这里的 <code>argint(0, &amp;mask)</code> 这句话，其用处是读取第一个 323232 位的参数。</em></p><p>最后收尾工作的函数（感觉有点像是 C++ 里的析构函数）就是 <code>freeproc()</code>，也和 <code>allocproc()</code> 一起，在 <code>kernel/proc.c</code> 这个文件中。那么我们直接在最后来一句 <code>p-&gt;trace_mask = 0;</code> 就可以了。</p><p>vim  kernel&#x2F;proc.c  </p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309152256360.png" alt="image-20230915225635294"></p><p>到这里，离完成这个 lab 就只剩最后一步了。</p><blockquote><p>  The trace system call should enable tracing for the process that  calls it and any children that it subsequently forks, but should not  affect other processes.</p></blockquote><p>也就是实现这句话说的功能，如果我们的父进程有 <code>trace_mask</code>，子进程也需要有相同的。因为创建子进程都需要用 <code>fork()</code>，那直接去改 <code>fork</code> 的源码就好了：</p><p>vim进入 proc.c：</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309152303080.png" alt="image-20230915230305961"></p><p><code>fork()</code> 的具体实现和上面的两个函数一样，还是在 <code>kernel/proc.c</code> 中（毕竟和进程有关）。</p><p>可以看到，第一行定义了两个 <code>struct proc</code>，一个是 <code>np</code>，一个是 <code>p</code>。因为代码中的注释，所以很明显可以看出来，这个 <code>np</code> 就是新的进程，那我们就完全不用管这里一堆看不懂的东西了，直接在中间来一个 <code>np-&gt;trace_mask = p-&gt;trace_mask</code>。</p><p>终于</p><p>终于</p><p>。。。。&#x2F;。&#x2F;。&#x2F;。，。，&#x2F;。，。&#x2F;，。。。，；，‘。。。&#x2F;&#x2F;</p><p>&#x3D;&#x3D;完结撒花&#x3D;&#x3D;</p><p>用时 4hour</p><p>感想是好累，。。。。&#x2F;哭&#x2F;  0_0  O.O  o_o</p><hr><p>通过这个实验，我完整清晰的了解到系统调用的全过程，加深了内核执行的理解。但是对xv6手册上面的一些概念理解还是有些不完全，比如陷入的概念，以及还是没掌握gdb调试。</p><p>实际上操作起来不用长时间，直接修改这里的指定文件的代码就好，但是整个学习过程还是很重要的，特别是前面的gdb调试，还有看xv6文档，理解系统调用的整个过程，都是蛮重要的。<br><a href="https://github.com/whileskies/xv6-labs-2020/blob/main/doc/Lab2-system%20calls.md">https://github.com/whileskies/xv6-labs-2020/blob/main/doc/Lab2-system%20calls.md</a></p><p>后续：真坑啊网上的教程。还以为没啥问题了，结果make qemu一跑就报错了。就是在sysproc.c里面的argint函数是没有返回值的，教程的代码错误的在if条件句里面进行判断了。</p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309152352456.png" alt="image-20230915235243247" style="zoom: 50%;" /><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309152358000.png" alt="image-20230915235808942" style="zoom: 67%;" /><p>终于能跑出了了。</p><p>时间已经是2023&#x2F;9&#x2F;15 23:52了。</p><p>踩坑日记：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F;  &#x2F;kernel&#x2F;sysproc.c&#x2F;sys_trace()uint64sys_trace()&#123;  int mask;  argint(0, &amp;mask)&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;！！！！这里要单独分出来  if (mask) &lt; 0)      return -1;  struct proc *pro &#x3D; myproc();  printf(&quot;trace pid: %d\n&quot;, pro-&gt;pid);  pro-&gt;trace_mask &#x3D; mask;  return 0;&#125; </code></pre><p>update:2023&#x2F;10&#x2F;2</p><p>笔记增加了系统调用的全过程的理解。</p><hr><h1 id="Lab03-1-page-table"><a href="#Lab03-1-page-table" class="headerlink" title="Lab03-1 page table"></a>Lab03-1 page table</h1><p>参考博客：<a href="https://ttzytt.com/2022/07/xv6_note/">https://ttzytt.com/2022/07/xv6_note/</a></p><p><a href="https://ttzytt.com/2022/07/xv6_lab3_record/">https://ttzytt.com/2022/07/xv6_lab3_record/</a></p><p>To help you learn about RISC-V page tables, and perhaps to aid future debugging, your first task is to write a function that prints  the contents of a page table. Now when you start xv6 it should print output like this, describing the page table of the first process at the point when it has just finished <code>exec()</code>ing <code>init</code>:   </p><p>为了帮助您了解RISC-V页表，也许是为了帮助将来进行调试，您的第一个任务是编写一个打印页表内容的函数。</p><p>定义一个名为 <code>vmprint()</code> 的函数。它应该接受一个 <code>pagetable_t</code> 参数，并以下面描述的格式打印该分页表。在 exec.c 中插入 <code>if(p-&gt;pid==1) vmprint(p-&gt;pagetable)</code> 的 <code>return argc</code> 前面，以打印第一个进程的页表。</p><p>现在当你启动 xv6 时，它应该像这样打印输出，描述第一个进程在刚刚完成 <code>exec()</code> ing <code>init</code> 时的页表：</p><pre class="line-numbers language-none"><code class="language-none">page table 0x0000000087f6e000..0: pte 0x0000000021fda801 pa 0x0000000087f6a000.. ..0: pte 0x0000000021fda401 pa 0x0000000087f69000.. .. ..0: pte 0x0000000021fdac1f pa 0x0000000087f6b000.. .. ..1: pte 0x0000000021fda00f pa 0x0000000087f68000.. .. ..2: pte 0x0000000021fd9c1f pa 0x0000000087f67000..255: pte 0x0000000021fdb401 pa 0x0000000087f6d000.. ..511: pte 0x0000000021fdb001 pa 0x0000000087f6c000.. .. ..510: pte 0x0000000021fdd807 pa 0x0000000087f76000.. .. ..511: pte 0x0000000020001c0b pa 0x0000000080007000</code></pre><p>第一行显示 的 <code>vmprint</code> 参数。之后，每个 PTE 都有一行，包括引用树中更深处的页表页面的 PTE。每条 PTE 线都缩进了一个数字 <code>&quot; ..&quot;</code> ，表示其在树中的深度。每个 PTE 行在其页表页中显示 PTE 索引、pte 位以及从 PTE 中提取的物理地址。不要打印无效的  PTE。在上面的示例中，顶级页表页具有条目 0 和 255 的映射。条目 0 的下一级仅映射索引 0，该索引 0 的下一级映射了条目 0、1 和 2。</p><p>Some hints:</p><pre class="line-numbers language-none"><code class="language-none">1.将vmprint()放进kernel&#x2F;vm.c2.使用文件 kernel&#x2F;riscv.h 末尾的宏3.在 kernel&#x2F;defs.h 中定义原型 vmprint ，以便可以从 exec.c 调用它4.可以参照freewalk.c进行递归遍历5.%p 在 printf 调用中使用以打印出完整的 64 位十六进制 PTE 和地址，如示例中所示</code></pre><p>实现代码:</p><p>先切换分支</p><pre class="line-numbers language-none"><code class="language-none">git checkout pgtbmake clean</code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c">void vmprint(pagetable_t pagetable, uint dep)&#123;  if(dep &#x3D;&#x3D; 0)    printf(&quot;page table %p\n&quot;, pagetable);  for(int i &#x3D; 0; i &lt; 512; i++)&#123;    pte_t pte &#x3D; pagetable[i];    if(pte &amp; PTE_V)&#123;      for(int j &#x3D; 0; j &lt; dep; j++)        printf(&quot;.. &quot;);      uint64 child &#x3D; PTE2PA(pte);      printf(&quot;..%d: pte %p pa %p\n&quot;, i, pte, child);      if(dep &lt; 2)        &#x2F;&#x2F; 如果层数等于 2 就不需要继续递归了，因为这是叶子节点        vmprint((pagetable_t) child, dep + 1);    &#125;  &#125; &#125;</code></pre><p>对于每个 <code>pagetable</code>，最多有 512 个节点，所以我们就依次遍历它们。如果发现这个页表是已分配的，也就是符合 <code>pte &amp; PTE_V == 1</code> 的，我们就继续递归。</p><p>在打印的时候，我们先需要打印出 <code>dep + 1</code> 个 <code>..</code>，然后再打印出 pte 和 pa。</p><p>这里指的 pte 指的是直接读取页表项的结果，而 pa 是去掉页表项中的标志位后得到的物理地址，我们通过这个物理地址可以找到下一层的页表项或是页帧。</p><p>注意可以这么 <code>pte_t pte = pagetable[i];</code> 写是因为，pa 指向的实际上是这个子页表的第一个元素，而 <code>pagetable[i]</code> 和 <code>*(pagetable + i)</code> 是等价的，也就是去访问第 i 个页表。</p><p>第一步：在&#x2F;kernel&#x2F;vm.c  最后新增代码段，保存退出</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309162323397.png" alt="image-20230916232306105"></p><p>第二步：然后在kernel&#x2F;exec.c中找到exec函数，添加代码段</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">if(p-&gt;pid &#x3D;&#x3D; 1)    vmprint(p-&gt;pagetable, 0);</code></pre><p>vim操作快捷键： 查找 &#x2F;xxx  （输入&#x2F;之后输入要查找的内容，比如要查找exec，就输入&#x2F;exec ，查询下一个时，先按回车，再按enter）</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309170911731.png" alt="image-20230917091101655"></p><p>&#x2F;kernel&#x2F;defs.h    在&#x2F;&#x2F;vm.c下面新增 一行  vmprint(pagetable_t,uint dep); 为了exec可以调用。</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309162343273.png"></p><p>最后编译 make qemu即可。</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309162345802.png" alt="image-20230916234541422"></p><p>一些补充：</p><p><strong>pagetable_t</strong>：</p><p>在 xv6 操作系统中，<code>pagetable_t</code> 结构用于表示页表。它是一个包含 512 个 <code>pte_t</code> 元素的数组。</p><p><code>pagetable_t</code> 的定义位于 <code>kernel/riscv.h</code> 文件中，如下所示：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F; Page table descriptor entrytypedef uint64_t pte_t;&#x2F;&#x2F; Page tabletypedef struct &#123;  pte_t ent[512];&#125; pagetable_t;</code></pre><p>上述定义中，<code>pte_t</code> 是一个 64 位的无符号整数类型，用于表示页表项（page table entry）。每个页表项包含有关虚拟地址和物理地址之间映射关系的信息。而 <code>pagetable_t</code> 结构体则由包含 512 个 <code>pte_t</code> 元素的数组 <code>ent</code> 组成，即 <code>ent</code> 是一个长度为 512 的 <code>pte_t</code> 类型的数组。</p><p>通过使用这种结构，xv6 能够灵活地管理和访问页表，以实现虚拟地址到物理地址的映射。</p><h1 id="Lab04-1-file-system"><a href="#Lab04-1-file-system" class="headerlink" title="Lab04-1 file system"></a>Lab04-1 file system</h1><p>xv6中文手册地址：<a href="http://xv6.dgs.zone/tranlate_books/book-riscv-rev1/c8/s0.html">http://xv6.dgs.zone/tranlate_books/book-riscv-rev1/c8/s0.html</a></p><p>lab地址：<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/fs.html">https://pdos.csail.mit.edu/6.S081/2020/labs/fs.html</a></p><p>参考：<a href="https://ttzytt.com/2022/08/xv6_lab10_record/">https://ttzytt.com/2022/08/xv6_lab10_record/</a></p><p><a href="https://github.com/whileskies/xv6-labs-2020/blob/main/doc/Lab9-file%20system.md">https://github.com/whileskies/xv6-labs-2020/blob/main/doc/Lab9-file%20system.md</a></p><hr><p>xv6book：</p><ul><li><a href="http://xv6.dgs.zone/tranlate_books/book-riscv-rev1/c8/s0.html">http://xv6.dgs.zone/tranlate_books/book-riscv-rev1/c8/s0.html</a></li><li>文件系统需要磁盘上的数据结构来表示目录和文件名称树，记录保存每个文件内容的块的标识，以及记录磁盘的哪些区域是空闲的。</li><li>文件系统必须支持崩溃恢复（crash recovery）。也就是说，如果发生崩溃（例如，电源故障），文件系统必须在重新启动后仍能正常工作。风险在于崩溃可能会中断一系列更新，并使磁盘上的数据结构不一致（例如，一个块在某个文件中使用但同时仍被标记为空闲）。</li><li>不同的进程可能同时在文件系统上运行，因此文件系统代码必须协调以保持不变量。</li><li>访问磁盘的速度比访问内存慢几个数量级，因此文件系统必须保持常用块的内存缓存。</li></ul><p>实现过程：</p><p>1.vim kernel&#x2F;sh.c  </p><p>找到这三行宏定义： 可以通过vim查找 &#x2F;NDIRECT 找到</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309171640492.png" alt="image-20230917164033360"></p><p>修改成：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#define NDIRECT 11#define DINDIRECTI (NDIRECT + 1)#define NINDIRECT (BSIZE &#x2F; sizeof(uint))#define MAXFILE (NDIRECT + NINDIRECT + NINDIRECT * NINDIRECT)</code></pre><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309171642880.png" alt="image-20230917164205815"></p><p>2.vim kernrl&#x2F;file.h</p><p>找到addrs[NDIECT+1];</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309171643389.png" alt="image-20230917164328329"></p><p>修改成uint addrs[NDIRECT+2];</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309171645022.png" alt="image-20230917164529946"></p><p>3.vim &#x2F;kernel&#x2F;fs.h</p><p>找到struct dinode，将addrs[NDIRECT+1]修改成+2</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309171648407.png" alt="image-20230917164838340"></p><p>4.vim kernel&#x2F;fs.c  找到bmap函数，修改成以下代码：</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309171718599.png" alt="image-20230917171828521"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">static uintbmap(struct inode *ip, uint bn)&#123;  uint addr, addr2, *a, *a2;  struct buf *bp, *bp2;  if(bn &lt; NDIRECT)&#123;    if((addr &#x3D; ip-&gt;addrs[bn]) &#x3D;&#x3D; 0)      ip-&gt;addrs[bn] &#x3D; addr &#x3D; balloc(ip-&gt;dev);    return addr;  &#125;  bn -&#x3D; NDIRECT;  if(bn &lt; NINDIRECT)&#123;    &#x2F;&#x2F; Load indirect block, allocating if necessary.    if((addr &#x3D; ip-&gt;addrs[NDIRECT]) &#x3D;&#x3D; 0)      ip-&gt;addrs[NDIRECT] &#x3D; addr &#x3D; balloc(ip-&gt;dev);    bp &#x3D; bread(ip-&gt;dev, addr);    a &#x3D; (uint*)bp-&gt;data;    if((addr &#x3D; a[bn]) &#x3D;&#x3D; 0)&#123;      a[bn] &#x3D; addr &#x3D; balloc(ip-&gt;dev);      log_write(bp);    &#125;    brelse(bp);    return addr;  &#125;    bn -&#x3D; NINDIRECT;  if(bn &lt; NINDIRECT * NINDIRECT)&#123;    uint dbn &#x3D; bn &#x2F; NINDIRECT;    uint dbnoff &#x3D; bn % NINDIRECT;    &#x2F;&#x2F; Load doubly-indirect block, allocating if necessary.    if((addr &#x3D; ip-&gt;addrs[DINDIRECTI]) &#x3D;&#x3D; 0)      ip-&gt;addrs[DINDIRECTI] &#x3D; addr &#x3D; balloc(ip-&gt;dev);    bp &#x3D; bread(ip-&gt;dev, addr);        a &#x3D; (uint*)bp-&gt;data;    if((addr2 &#x3D; a[dbn]) &#x3D;&#x3D; 0)&#123;      a[dbn] &#x3D; addr2 &#x3D; balloc(ip-&gt;dev);      log_write(bp);    &#125;    brelse(bp);    &#x2F;&#x2F;printf(&quot;addr2: %d\n&quot;, addr2);    bp2 &#x3D; bread(ip-&gt;dev, addr2);    a2 &#x3D; (uint*)bp2-&gt;data;    if((addr &#x3D; a2[dbnoff]) &#x3D;&#x3D; 0)&#123;      a2[dbnoff] &#x3D; addr &#x3D; balloc(ip-&gt;dev);      log_write(bp2);    &#125;    brelse(bp2);    return addr;  &#125;  panic(&quot;bmap: out of range&quot;);&#125;</code></pre><p>5.vim  kernel&#x2F;fs.c   找到itrunc函数</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309171720290.png" alt="image-20230917172019225"></p><p>修改成</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">voiditrunc(struct inode *ip)&#123;  int i, j;  struct buf *bp, *bp2;  uint *a, *a2;  for(i &#x3D; 0; i &lt; NDIRECT; i++)&#123;    if(ip-&gt;addrs[i])&#123;      bfree(ip-&gt;dev, ip-&gt;addrs[i]);      ip-&gt;addrs[i] &#x3D; 0;    &#125;  &#125;  if(ip-&gt;addrs[NDIRECT])&#123;    bp &#x3D; bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);    a &#x3D; (uint*)bp-&gt;data;    for(j &#x3D; 0; j &lt; NINDIRECT; j++)&#123;      if(a[j])        bfree(ip-&gt;dev, a[j]);    &#125;    brelse(bp);    bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);    ip-&gt;addrs[NDIRECT] &#x3D; 0;  &#125;  if(ip-&gt;addrs[DINDIRECTI])&#123;    bp &#x3D; bread(ip-&gt;dev, ip-&gt;addrs[DINDIRECTI]);    a &#x3D; (uint*)bp-&gt;data;    for(i &#x3D; 0; i &lt; NINDIRECT; i++)&#123;      if(a[i])&#123;        bp2 &#x3D; bread(ip-&gt;dev, a[i]);        a2 &#x3D; (uint*)bp2-&gt;data;        for(j &#x3D; 0; j &lt; NINDIRECT; j++)&#123;          if(a2[j])            bfree(ip-&gt;dev, a2[j]);        &#125;        brelse(bp2);        bfree(ip-&gt;dev, a[i]);      &#125;    &#125;    brelse(bp);    bfree(ip-&gt;dev, ip-&gt;addrs[DINDIRECTI]);    ip-&gt;addrs[DINDIRECTI] &#x3D; 0;  &#125;  ip-&gt;size &#x3D; 0;  iupdate(ip);&#125;</code></pre><p>6.vim kernel&#x2F;file.c   </p><p>找到filewrite() 中的int max&#x3D;…  一行</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309171721118.png" alt="image-20230917172141017"></p><p>修改成</p><pre class="line-numbers language-none"><code class="language-none">int max &#x3D; ((MAXOPBLOCKS-1-2-2) &#x2F; 2) * BSIZE;</code></pre><p>到此&#x3D;&#x3D;完结撒花&#x3D;&#x3D;</p><p>测试：</p><p>启动xv6，发现可以正常启动，说明代码修改没有出现编译问题。</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309171724792.png" alt="image-20230917172440718"></p><h1 id="Lab05-01-net-working"><a href="#Lab05-01-net-working" class="headerlink" title="Lab05-01 net working"></a>Lab05-01 net working</h1><p>实验地址：<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/net.html">https://pdos.csail.mit.edu/6.S081/2020/labs/net.html</a></p><p>学习参考：<a href="https://ttzytt.com/2022/08/xv6_lab8_record/">https://ttzytt.com/2022/08/xv6_lab8_record/</a>    &#x3D;&#x3D;必看！！！&#x3D;&#x3D;</p><hr><p>切换分支：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">git  stash save &quot;filesys&quot;   git checkout net make clean</code></pre><p>实验任务：</p><p>完成函数e1000_transmit()   and       e1000_recv()</p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309172129027.png" alt="image-20230917212916907" style="zoom:67%;" /><p>这个实验的lab描述我实在是服了。。长长一大串。。</p><p>一些定义</p><p><strong>vim kernel&#x2F;e1000_dev.h可以看到所有的宏定义</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F;TX表示数据的发送（Transmission），而RX表示数据的接收（Reception）。这个X并没有特定的意义，只是用来代表这两个术语的首字母。&#x2F;&#x2F;发送方#define E1000_RDH      (0x02810&#x2F;4)  &#x2F;* RX Descriptor Head - RW *&#x2F;   头指针#define E1000_RDT      (0x02818&#x2F;4)  &#x2F;* RX Descriptor Tail - RW *&#x2F;   尾指针#define E1000_RDLEN    (0x02808&#x2F;4)  &#x2F;* RX Descriptor Length - RW *&#x2F; 环形队列的长度&#x2F;&#x2F;接收方#define E1000_TDLEN    (0x03808&#x2F;4)  &#x2F;* TX Descriptor Length - RW *&#x2F;#define E1000_TDH      (0x03810&#x2F;4)  &#x2F;* TX Descriptor Head - RW *&#x2F;#define E1000_TDT      (0x03818&#x2F;4)  &#x2F;* TX Descripotr Tail - RW *&#x2F;        &#x2F;&#x2F; [E1000 3.3.3]struct tx_desc   &#x2F;&#x2F;发送方描述结构&#123;  uint64 addr;  uint16 length;  uint8 cso;  uint8 cmd;  uint8 status;  uint8 css;  uint16 special;&#125;;&#x2F;* Receive Descriptor bit definitions [E1000 3.2.3.1] *&#x2F;#define E1000_RXD_STAT_DD       0x01    &#x2F;* Descriptor Done *&#x2F;  #define E1000_RXD_STAT_EOP      0x02    &#x2F;* End of Packet *&#x2F;&#x2F;&#x2F; [E1000 3.2.3]struct rx_desc   &#123;  uint64 addr;       &#x2F;* Address of the descriptor&#39;s data buffer *&#x2F;  uint16 length;     &#x2F;* Length of data DMAed into data buffer *&#x2F;  uint16 csum;       &#x2F;* Packet checksum *&#x2F;  uint8 status;      &#x2F;* Descriptor status *&#x2F;  uint8 errors;      &#x2F;* Descriptor Errors *&#x2F;  uint16 special;&#125;;</code></pre><p>在e1000.c 中 </p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#define TX_RING_SIZE 16static struct tx_desc tx_ring[TX_RING_SIZE] __attribute__((aligned(16)));static struct mbuf *tx_mbufs[TX_RING_SIZE];#define RX_RING_SIZE 16static struct rx_desc rx_ring[RX_RING_SIZE] __attribute__((aligned(16)));static struct mbuf *rx_mbufs[RX_RING_SIZE];</code></pre><hr><p>transmit()</p><p>发送   e1000_transmit()： </p><p>vim kernel&#x2F;e1000.c    在此处增加代码：</p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309181313776.png" alt="image-20230918131324675" style="zoom: 67%;" /><p>实现代码为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">inte1000_transmit(struct mbuf *m)&#123;  acquire(&amp;e1000_lock);   &#x2F;&#x2F;获取网络设备的锁，确保在使用网络设备时只有一个进程在执行  int tail &#x3D; regs[E1000_TDT];    &#x2F;*    tx_ring[tail].status    用于访问 tx_ring 数组中索引为 tail 的元素的 status 字段。这个字段表示传输描述符（transmit descriptor）的状态。E1000_TXD_STAT_DD 是一个常量值，它表示传输描述符的“传输完成”状态。 这个状态位用于指示数据包已经成功发送。    *&#x2F;  if(!(tx_ring[tail].status &amp; E1000_TXD_STAT_DD))&#123;         release(&amp;e1000_lock);  &#x2F;&#x2F;队列满，释放锁    return -1;&#x2F;&#x2F;返回错误  &#125;    if(tx_mbufs[tail])  &#x2F;&#x2F;释放之前发送队列的末尾tail数据包对应的内存空间（如果存在）    mbuffree(tx_mbufs[tail]);    &#x2F;&#x2F;填充 tx_ring[tail] 数据结构中的字段：cmd 域和 length 域用于控制数据包的发送方式，addr 域指向待发送的数据块的地址；  memset(&amp;tx_ring[tail], 0, sizeof(struct tx_desc));  tx_ring[tail].cmd &#x3D; (E1000_TXD_CMD_EOP | E1000_TXD_CMD_RS);  tx_ring[tail].addr &#x3D; (uint64)m-&gt;head;  tx_ring[tail].length &#x3D; m-&gt;len;  &#x2F;&#x2F;将 m 对应的数据块添加到发送队列中  tx_mbufs[tail] &#x3D; m;     &#x2F;&#x2F;更新 E1000_TDT 寄存器，指向新的尾指针。  regs[E1000_TDT] &#x3D; (tail + 1) % TX_RING_SIZE;      &#x2F;&#x2F;最后函数释放网络设备的锁，并返回 0，表示数据包已经成功添加到发送队列中。  release(&amp;e1000_lock);  return 0;&#125;</code></pre><p>代码中的定义都可以在上面的<strong>一些定义</strong>中看到</p><p>recv()</p><p>vim kernel&#x2F;e1000.c   e1000_recv(void):</p><p>在23行以及33行添加代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">struct spinlock e1000_lockrx;&#x2F;&#x2F; e1000_init()initlock(&amp;e1000_lockrx, &quot;e1000_rx&quot;);</code></pre><p>插入之后如下所示：</p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309181326166.png" alt="image-20230918132640088" style="zoom:67%;" /><p>接着找到e1000_recv函数：</p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309181316280.png" alt="image-20230918131629212" style="zoom:67%;" /><p>添加代码如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">static voide1000_recv(void)&#123;  while(1)&#123; &#x2F;&#x2F;进入无限循环，不断接受网络数据包    &#x2F;&#x2F;获取下一个接收队列描述符的索引（idx），这里使用了环形缓冲区（RX_RING）来存储接收队列。    uint idx &#x3D; (regs[E1000_RDT] + 1) % RX_RING_SIZE;    &#x2F;&#x2F;根据索引获取该接收队列描述符（desc）的指针    struct rx_desc *desc &#x3D; &amp;rx_ring[idx];     &#x2F;&#x2F;判断该接收队列描述符的状态标志位（status）是否为“数据接收完成”（DD）。如果没有，则返回并等待下一个数据包。    if(!(desc-&gt;status &amp; E1000_RXD_STAT_DD))&#123;      return;    &#125;     &#x2F;&#x2F;从接收缓冲区（rx_mbufs）中获取对应的网络数据包（mbuf），并设置其长度为接收队列描述符中指定的长度。    rx_mbufs[idx]-&gt;len &#x3D; desc-&gt;length;    &#x2F;&#x2F;将该网络数据包传递给net_rx函数进行处理。    net_rx(rx_mbufs[idx]);    &#x2F;&#x2F;分配一个新的接收缓冲区（mbuf），并将其指针存储在接收队列描述符中指定的地址（addr）中    rx_mbufs[idx] &#x3D; mbufalloc(0);    desc-&gt;addr &#x3D; rx_mbufs[idx]-&gt;head;    desc-&gt;status &#x3D; 0;&#x2F;&#x2F;将接收队列描述符的状态标志位清零（status &#x3D; 0）    regs[E1000_RDT] &#x3D; idx;&#x2F;&#x2F;更新接收队列的读指针（E1000_RDT）为下一个接收队列描述符的索引（idx）  &#125;&#125;</code></pre><p>代码中的定义都可以在上面的<strong>一些定义</strong>中看到</p><hr><p>:wq保存退出。重新编译，没出现问题。</p><p>&#x3D;&#x3D;完结撒花&#x3D;&#x3D;</p><p>再说一遍必看：<a href="https://ttzytt.com/2022/08/xv6_lab8_record/">https://ttzytt.com/2022/08/xv6_lab8_record/</a></p><p>终于结束了。真有种轻舟已过万重山的感觉。。。。。😅😅😅😅😅😅😅😅😅😅😅😅😅😅😅😅😅😅😅😅</p><hr><h1 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h1><h2 id="定制你的shell"><a href="#定制你的shell" class="headerlink" title="定制你的shell"></a>定制你的shell</h2><p>1、 定制shell启动欢迎界面</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309152215059.png" alt="image-20230915221550839"></p><p>vim kernel&#x2F;main.c</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309171525400.png" alt="image-20230917152542285"></p><p>在这个位置插入你想自定义的欢迎界面。</p><p>如果你也想有上面的特殊字串，click这个网站：<a href="http://patorjk.com/software/taag/#p=testall&f=Mer&t=Hello%20World">http://patorjk.com/software/taag/#p=testall&amp;f=Mer&amp;t=Hello%20World</a></p><p>2、定制命令提示符</p><p>vim user&#x2F;sh.c   getcmd</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309171529910.png" alt="image-20230917152941849"></p><p>修改write(2,”$”,2);即可。第三个参数2是截取第二个参数字符串的长度。</p><p>修改成学号可更改为 write(2,”20212131102$ “,13);   多留一个空格出来，因此截取长度设置为13。</p><h2 id="linux常用命令"><a href="#linux常用命令" class="headerlink" title="linux常用命令"></a>linux常用命令</h2><p>ls  显示当前目录下所有文件  可选参数 -a  -l </p><p>history  显示输入命令历史</p><p>cd  进入文件夹    cd .. 返回上一级</p><p>cp 拷贝copy        cp A B     把A复制一份并且命名为B</p><p>rm  删除remove      rm a</p><p>mv 重命名   mv a  b  把A重命名为B</p><h2 id="vim常用命令"><a href="#vim常用命令" class="headerlink" title="vim常用命令"></a>vim常用命令</h2><p>i 插入模式</p><p>:set nu  显示行号</p><p>gg 回到顶部</p><p>g跳到尾部</p><p>u撤销</p><p>o在下一行插入</p><p>h j k l   左下上右</p><p>w下一个单词</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;参考指导手册：&lt;/p&gt;
&lt;p&gt;xv6中文指导手册：&lt;a href=&quot;http://xv6.dgs.zone/&quot;&gt;http://xv6.dgs.zone/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;实验中文翻译：&lt;a href=&quot;http://xv6.dgs.zone/labs/req</summary>
      
    
    
    
    
    <category term="操作系统" scheme="https://hopefuling.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>大数据技术原理与应用（导入篇）</title>
    <link href="https://hopefuling.github.io/2023/10/01/BigData/"/>
    <id>https://hopefuling.github.io/2023/10/01/BigData/</id>
    <published>2023-10-01T08:49:03.000Z</published>
    <updated>2023-10-02T09:23:20.047Z</updated>
    
    <content type="html"><![CDATA[<p>弱鸡学大数据&#x3D;_&#x3D;</p><p>视频学习：厦门大学林子雨老师 <a href="https://www.bilibili.com/video/BV1ds41157NS?p=83&vd_source=b0c1d863140b2d5070f5b01941c51135">https://www.bilibili.com/video/BV1ds41157NS?p=83&amp;vd_source=b0c1d863140b2d5070f5b01941c51135</a></p><p>林子雨老师数据库实验室网站：<a href="https://dblab.xmu.edu.cn/blog/category/big-data/">https://dblab.xmu.edu.cn/blog/category/big-data/</a></p><hr><h1 id="Hadoop实践"><a href="#Hadoop实践" class="headerlink" title="Hadoop实践"></a>Hadoop实践</h1><p>资料收集</p><p>官方手册：<a href="https://hadoop.apache.org/docs/r1.0.4/cn/hdfs_user_guide.html">https://hadoop.apache.org/docs/r1.0.4/cn/hdfs_user_guide.html</a></p><p>常见命令：</p><p>启动Hadoop：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd &#x2F;usr&#x2F;local&#x2F;hadoop.&#x2F;sbin&#x2F;start-dfs.sh #启动hadoop</code></pre><p>在HDFS中为hadoop用户创建一个用户目录：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.&#x2F;bin&#x2F;hdfs dfs -mkdir -p &#x2F;user&#x2F;hadoop</code></pre><p>注：“-p”表示如果是多级目录，则父目录和子目录一起创建，这里“&#x2F;user&#x2F;hadoop”就是一个多级目录，因此必须使用参数“-p”，否则会出错。</p><p>显示HDFS中与当前用户hadoop对应的用户目录下的内容：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.&#x2F;bin&#x2F;hdfs dfs -ls .  等价于.&#x2F;bin&#x2F;hdfs dfs -ls &#x2F;user&#x2F;hadoop</code></pre><p>列出HDFS上的所有目录：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.&#x2F;bin&#x2F;hdfs dfs -ls</code></pre><p>使用rm命令删除一个目录（不是“&#x2F;user&#x2F;hadoop&#x2F;input”目录）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.&#x2F;bin&#x2F;hdfs dfs -rm -r &#x2F;input</code></pre><p>“-r”参数表示如果删除“&#x2F;input”目录及其子目录下的所有内容，如果要删除的一个目录包含了子目录，则必须使用“-r”参数，否则会执行失败。</p><p>上传文件&#x2F;下载文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">上传到hdfs：.&#x2F;bin&#x2F;hdfs dfs -put   </code></pre><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309071109292.png" alt="image-20230904155035472"></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">下载到本地机：.&#x2F;bin&#x2F;hdfs dfs -get</code></pre><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309261502168.png" alt="image-20230926150226075"></p><p>拷贝文件   cp A  to B</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.&#x2F;bin&#x2F;hdfs dfs -cp input&#x2F;myLocalFile.txt   &#x2F;input</code></pre><hr><p>Hadoop由三个核心组件组成：</p><ul><li><strong>Hadoop Distributed File System</strong> <strong>(HDFS) –</strong> It is the storage layer of Hadoop.<br>Hadoop分布式文件系统（HDFS） - 它是Hadoop的存储层。</li><li><strong>Map-Reduce –</strong> It is the data processing layer of Hadoop.<br>Map-Reduce – 它是Hadoop的数据处理层。</li><li><strong>YARN –</strong> It is the resource management layer of Hadoop.<br>YARN – 它是Hadoop的资源管理层。</li></ul><h1 id="HBase"><a href="#HBase" class="headerlink" title="HBase"></a>HBase</h1><p>环境配置：<a href="https://dblab.xmu.edu.cn/blog/4252/">https://dblab.xmu.edu.cn/blog/4252/</a></p><p>三种运行模式：</p><ol><li>单机模式：在一台计算机上安装和使用HBase，不涉及数据的分布式存储</li><li>伪分布式模式：在一台计算机上模拟一个小的集群</li><li>分布模式：使用多台计算机实现物理意义上的分布式存储</li></ol><h2 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h2><p>启动HBase：首先切换目录至HBase安装目录&#x2F;usr&#x2F;local&#x2F;hbase；再启动HBase。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd &#x2F;usr&#x2F;local&#x2F;hbasebin&#x2F;start-hbase.shbin&#x2F;hbase shell</code></pre><p>关闭HBase：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">bin&#x2F;stop-hbase.sh</code></pre><p>语句[export HBASE_MANAGES_ZK&#x3D;true]表示采用HBase自带的ZooKeeper管理。如果想用外部<br>ZooKeeper管理HBase,可以自行安装、配置ZooKeeper,再把该句删除。</p><p>正确运行关闭顺序：启动Hadoop -&gt; 启动HBase  -&gt; 关闭HBase -&gt;关闭Hadoop</p><h2 id="配置问题"><a href="#配置问题" class="headerlink" title="配置问题"></a>配置问题</h2><p><code>**The authenticity of host &#39;127.0.0.1&#39;(127.0.0.1)&#39;  can&#39;t be established.**</code></p><p>启动Hbase的时候出现了这个问题：。。。。。</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309071110516.png" alt="image-20230905165954225"></p><p>前面的一大段报错信息和jps没有显示HQuorumPeer，网上寻找解决方案之后，确定是ssh的问题：</p><p>关闭HBase时也出现错误：</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309071110267.png" alt="image-20230905215906381"></p><p>解决方案：</p><p>操作文件或目录的用户，有3种不同类型：<strong>文件所有者、群组用户、其他用户</strong>。最高位表示文件所有者的权限值，中间位表示群组用户的权限值，最低位则表示其他用户的权限值，所以，chmod 777中，三个数字7分别对应上面三种用户，权限值都为7。</p><p>设置文件或目录的777权限意味着所有用户都可以读取，写入和执行文件或目录。</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309071110651.png" alt="image-20230905214609675"></p><p>在文件末尾加上</p><pre class="line-numbers language-none"><code class="language-none">StrictHostKeyChecking noUserKnownHostsFile &#x2F;dev&#x2F;null</code></pre><p>整个文件如下：</p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309071111587.png" alt="image-20230905215351379" style="zoom:50%;" /><p>:wq保存之后再次连接  ssh localhost</p><p>终于解决了：</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309071110060.png" alt="image-20230905214700712"></p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309071111597.png" alt="image-20230905204244949"></p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309071111922.png" alt="image-20230905204340037"></p><p>进入shell界面：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">bin&#x2F;hbase shell</code></pre><p>这里启动会稍慢，需要等待一会儿</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309071111704.png" alt="image-20230905164228873"></p><p>关闭HBase也没有出现错误了（之前报 no master）</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309071111021.png" alt="image-20230905214816072"></p><h2 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h2><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">#创建表：create  &#39;student&#39;,&#39;Sname&#39;,&#39;Ssex&#39;,&#39;Sage&#39;,&#39;Sdept&#39;,&#39;course&#39;#查看表的基本信息describle &#39;student&#39;#增  put &#39;student&#39;,&#39;95001&#39;,&#39;Sname&#39;,&#39;LiYing&#39;   #即为student表添加了学号为95001，名字为LiYing的一行数据，其行键为95001。#删#删除数据delete &#39;student&#39;,&#39;95001&#39;,&#39;Ssex&#39;  #即删除了student表中95001行下的Ssex列的所有数据deleteall &#39;student&#39;,&#39;95001&#39;   #即删除了student表中的95001行的全部数据#删除表   删除表有两步，第一步先让该表不可用，第二步删除表。disable &#39;student&#39;  drop &#39;student&#39;#查#HBase中有两个用于查看数据的命令：1. get命令，用于查看表的某一行数据；2. scan命令用于查看某个表的全部数据。get &#39;student&#39;,&#39;95001&#39;   #返回的是‘student’表‘95001’行的数据scan &#39;student&#39;#返回的是‘student’表的全部数据#查询表的历史版本，需要两步。create &#39;teacher&#39;,&#123;NAME&#x3D;&gt;&#39;username&#39;,VERSIONS&#x3D;&gt;5&#125;  #1、在创建表的时候，指定保存的版本数（假设指定为5）     put &#39;teacher&#39;,&#39;91001&#39;,&#39;username&#39;,&#39;Mary&#39;   #2、插入数据然后更新数据，使其产生历史版本数据，注意：这里插入数据和更新数据都是用put命令put &#39;teacher&#39;,&#39;91001&#39;,&#39;username&#39;,&#39;Mary1&#39;put...get &#39;teacher&#39;,&#39;91001&#39;,&#123;COLUMN&#x3D;&gt;&#39;username&#39;,VERSIONS&#x3D;&gt;5&#125; #查询时，指定查询的历史版本数。默认会查询出最新的数据。（有效取值为1到5）</code></pre><p>关闭HBase：exit</p><p>注意：这里退出HBase数据库是退出对数据库表的操作，而不是停止启动HBase数据库后台运行(需要运行.&#x2F;sbin&#x2F;stop-hbash.sh)。</p><h2 id="编程实例"><a href="#编程实例" class="headerlink" title="编程实例"></a>编程实例</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">import org.apache.hadoop.conf.Configuration;import org.apache.hadoop.hbase.*;import org.apache.hadoop.hbase.client.*;import org.apache.hadoop.hbase.util.Bytes; import java.io.IOException;public class ExampleForHBase &#123;    public static Configuration configuration; &#x2F;&#x2F;对配置信息管理的一个类    public static Connection connection;   &#x2F;&#x2F;对连接进行管理的一个类    public static Admin admin;   &#x2F;&#x2F;对数据库进行管理的一个类，用于管理对表的创建删除     public static void main(String[] args)throws IOException&#123;        init();        createTable(&quot;student&quot;,new String[]&#123;&quot;score&quot;&#125;);        insertData(&quot;student&quot;,&quot;zhangsan&quot;,&quot;score&quot;,&quot;English&quot;,&quot;69&quot;);        insertData(&quot;student&quot;,&quot;zhangsan&quot;,&quot;score&quot;,&quot;Math&quot;,&quot;86&quot;);        insertData(&quot;student&quot;,&quot;zhangsan&quot;,&quot;score&quot;,&quot;Computer&quot;,&quot;77&quot;);                getData(&quot;student&quot;, &quot;zhangsan&quot;, &quot;score&quot;,&quot;English&quot;);        close();    &#125;     public static void init()&#123;        configuration  &#x3D; HBaseConfiguration.create();        &#x2F;&#x2F;设置HBase存储的根路径，效果等同于创建hbase-site.xml文件写入路径信息        &#x2F;&#x2F;伪分布式路径为hdfs:&#x2F;&#x2F;localhost:9000&#x2F;hbase；单机路径为file:&#x2F;&#x2F;&#x2F;DIRECTORT&#x2F;hbase        configuration.set(&quot;hbase.rootdir&quot;,&quot;hdfs:&#x2F;&#x2F;localhost:9000&#x2F;hbase&quot;);        try&#123;            connection &#x3D; ConnectionFactory.createConnection(configuration);            admin &#x3D; connection.getAdmin();        &#125;catch (IOException e)&#123;            e.printStackTrace();        &#125;    &#125;     public static void close()&#123;        try&#123;            if(admin !&#x3D; null)&#123;                admin.close();            &#125;            if(null !&#x3D; connection)&#123;                connection.close();            &#125;        &#125;catch (IOException e)&#123;            e.printStackTrace();        &#125;    &#125;     &#x2F;*创建表 *@param myTableName 表名 *  @param colFamily 列族数组 *  @throws Exception *&#x2F;    public static void createTable(String myTableName,String[] colFamily) throws IOException &#123;        TableName tableName &#x3D; TableName.valueOf(myTableName);        if(admin.tableExists(tableName))&#123;            System.out.println(&quot;talbe is exists!&quot;);        &#125;else &#123;            TableDescriptorBuilder tableDescriptor &#x3D; TableDescriptorBuilder.newBuilder(tableName);            for(String str:colFamily)&#123;                ColumnFamilyDescriptor family &#x3D; ColumnFamilyDescriptorBuilder.newBuilder(Bytes.toBytes(str)).build();                tableDescriptor.setColumnFamily(family);            &#125;            admin.createTable(tableDescriptor.build());        &#125;     &#125; &#x2F;&#x2F;添加数据四维：表名 行键 列族 列名    public static void insertData(String tableName,String rowKey,String colFamily,String col,String val) throws IOException &#123;         Table table &#x3D; connection.getTable(TableName.valueOf(tableName));        Put put &#x3D; new Put(rowKey.getBytes());        put.addColumn(colFamily.getBytes(),col.getBytes(), val.getBytes());        table.put(put);        table.close();     &#125;     public static void getData(String tableName,String rowKey,String colFamily, String col)throws  IOException&#123;         Table table &#x3D; connection.getTable(TableName.valueOf(tableName));        Get get &#x3D; new Get(rowKey.getBytes());        get.addColumn(colFamily.getBytes(),col.getBytes());        &#x2F;&#x2F;result类管理输出的结果        Result result &#x3D; table.get(get);         System.out.println(new String(result.getValue(colFamily.getBytes(),col&#x3D;&#x3D;null?null:col.getBytes())));        table.close();     &#125;&#125;</code></pre><p>Java与shell命令：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;查看张三的English成绩：java: getData(&quot;student&quot;,&quot;zhangsan&quot;,&quot;score&quot;,&quot;English&quot;);shell: get &#39;student&#39;,&#39;zhangsan&#39;,&#123;COLUMN&#x3D;&gt;&#39;score:English&#39;&#125;; &#x2F;&#x2F;插入数据：java： insertData:(&quot;student&quot;.&quot;zhangsan&quot;,&quot;score&quot;,&quot;English&quot;,&quot;69&quot;);shell:  put &#39;student&#39;,&#39;zhangsan&#39;,&#39;score:English&#39;,&#39;69&#39;;</code></pre><h1 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h1><h1 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h1><p>C: 一致性（Consistency）指任何一个读操作总能读到之前完成的写操作的结果。也就是说在我们分布式环境中，多点的数据必须是一致的。所有节点在同一时间要具有相同的数据。<br>A: 可用性（Availability）指快速的获取数据，可以在确定时间内返回操作结果，保证每个请求不管成功还是失败都有响应。<br>P: 分区容忍性（Partition tolerance）指当网络出现分区的情况（即系统中的一部分节点无法和其他节点进行通信）分离的系统也能够正常运行。即：系统中任意信息丢失不会影响系统正常运作</p><h1 id="NewSQL"><a href="#NewSQL" class="headerlink" title="NewSQL"></a>NewSQL</h1><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309261304620.png" alt="image-20230926130424433"></p><h1 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h1><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309261307573.png" alt="image-20230926130714370"></p><p>一个MongDb可以建立多个数据库</p><p>MongDB的默认数据库为”db“，该数据库存储在data目录中</p><p>MongDB的单个实例可以容纳多个独立的数据库，每一个都有自己的集合和权限，不同的数据库也放置在不同的文件中</p><p>文档</p><p>文档是一个键值（key-value）对，即BSON；MongDB的文档不需要设置相同的字段，并且相同的字段不需要相同的数据类型</p><p>一个键值对就是一个文档</p><p>RDMBMS与MongoDB对应的术语</p><table><thead><tr><th></th><th>数据库服务端和客户端</th></tr></thead><tbody><tr><td>Mysqld&#x2F;Oracle</td><td>mongod</td></tr><tr><td>mysql&#x2F;sqlplus</td><td>mongo</td></tr></tbody></table><p>集合</p><p>集合就是MongoDB文档组，类似于RDBMS中的表格。集合存在于数据库中，没有固定的结构，可对集合插入不同形式和类型的数据</p><h1 id="Hive"><a href="#Hive" class="headerlink" title="Hive"></a>Hive</h1><p>Hive本身并不支持数据存储和处理，可以看作是提供了一种编程语言，依赖于分布式文件系统HDFS存储数据、分布式并行计算模型MapReduce处理数据，并借鉴了SQL语言设计了新的查询语言HiveQL，支持类似SQL的接口，很容易移植。</p><p>Hive具有两方面特性：</p><p>（1）采用批处理方式处理海量数据</p><p>Hive会把HiveQL语句转换成MapReduce任务进行；数据仓库存储的是静态数据，对静态数据的分析适合采用批处理方式，不需要快速响应给出结果，而且数据本身也不会频繁变化</p><p>（2）Hive提供了一系列对数据进行提取、转换、加载（ETL）的工具</p><p>可以存储、查询和分析存储在Hadoop中的大规模数据；这些工具能够很好地满足数据仓库各种应用场景。</p><p>与Pig的区别：</p><p>Pig主要用于数据仓库的ETL环节；Hive主要用于数据仓库海量数据的批处理分析。</p><p>与传统数据库的区别：</p><ul><li>数据插入：只支持批量导入</li><li>数据更新：不支持数据更新</li><li>支持索引、分区</li><li>执行延迟高</li><li>扩展性好</li></ul><p>对外访问提供的接口：</p><ul><li>CLI：一种命令行工具</li><li>HWI：Hive Web Interface 是Hive的Web接口</li><li>JDBC和ODBC：开放数据库连接接口</li><li>Thrift Server：基于Thrift架构开发的接口，允许外界通过这个接口，实现对Hive仓库的RPC调用</li></ul><p>驱动模块（Driver）：</p><p>包含编译器、优化器、执行器，负责把HiveQL语句转化成一系列MapReduce作业</p><p>元数据存储模块（Metastore）:</p><p>是一个独立的关系型数据库，，可以通过Mysql存储</p><p>Hive HA（Hive High Avalability高可用性解决方案）：</p><p>基本原理：</p><p>对外添加HAproxy访问</p><hr><p>当启动MapReduce程序时，Hive是不会生成MapReduce程序的，需要通过一个表示‘Job执行计划“的xml文件驱动执行内置的、原生的Mapper和Reducer模块。Hive通过JobTracker通信来初始化MapReduce任务，不必部署在JobTracker所在的管理节点上执行</p><h1 id="Impala"><a href="#Impala" class="headerlink" title="Impala"></a>Impala</h1><p>三大组件：</p><p>Impalad：负责协调客户端提交的查询的执行，与HDFS的数据节点运行在同一节点上</p><p>Statestore：负责收集分布在集群中各个Impalad进程的资源信息用于查询调度</p><p>CLI：给用户提供查询使用的命令行工具</p><p>同时也提供了Hue、JDBC及ODBC的使用接口</p><p>Impala的元数据是直接存储在Hive中的，它是借助Hive来存储Impala的元数据。Impala采用与Hive相同的元数据、相同的SQL语法、相同的ODBC驱动程序和用户接口——为了在一个Hadoop平台上可以统一部署Hive和Impala等分析工具，实现在一个平台上可以同时满足批处理和实时查询。</p><p>Impala查询执行过程：</p><ol><li>当用户提交查询时，Impala先创建一个负责协调客户端提交的查询的Impala进程，该进程会向Impala State Store提交注册订阅信息，State Store会创建一个statestore进程，statestored进程通过创建多个线程来处理Impala的注册订阅信息。</li><li>用户通过CLI客户端提交一个查询到impala进程，Impala的Query Planner对SQL语句进行解析，生成解析树，Planner把这个查询的解析树变成若干PlannerFragment，发送到Query Coordinator.</li><li>Coordinator通过Mysql元数据中获取元数据，从HDFS的名称节点中获取数据地址，以得到存储这个查询相关数据的所有节点</li><li>Coordinator初始化相应impalad上的任务执行，即把查询任务分配给所有存储这个查询相关数据的数据节点</li><li>Query Executor 通过流式交换中间输出，并由Query Coordinator 汇聚来自各个impalad的结果</li><li>Coordinator 把汇总后的结果返回给CLI客户端</li></ol><p>Impala与HIve比较：</p><p>不同点：</p><ol><li>Hive比较适合长时间的批处理查询分析，而Impala适合实时交互式SQL查询；</li><li>Hive依赖于Mapreduce计算框架，Impala把执行计划表现为一棵完整的执行计划树，直接分发执行计划到各个Impala执行查询。</li><li>Hive在执行过程中，如果内存放不下所有数据则会使用外存，以保证查询能顺利执行；而Impala在遇到内存放不下的时候，不会利用外存，所以Impala目前处理查询时会受到一定的的限制。</li></ol><p>相同点：</p><ol><li>Hive与Impala使用相同的存储数据池，，都支持把数据存储与HDFS和HBase中；</li><li>Hive和Impala使用相同的元数据</li><li>Hive与Impala中对SQL的解释处理比较相似，都是通过词法分析生成执行计划</li></ol><p>实际使用上应该将两者结合起来使用：可以先使用Hive进行数据转换处理，之后再使用Impala，在Hive处理后的结果数据集上进行快速的数据分析。</p><p><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202309301725536.png" alt="image-20230930172529321"></p><h1 id="YARN"><a href="#YARN" class="headerlink" title="YARN"></a>YARN</h1><p>与MappReduce1.0的比较：</p><ol><li>MapReduce1.0既是一个计算框架，又是一个资源管理调度框架，但是只能支持MapReduce编程框架；YARN是一个纯粹的资源调度管理框架，在它上面可以允许包括MapReduce在内的不同类型的计算框架（只要编程实现相应的ApplicationMaster）</li><li>YARN以容器为单位，而不是以slot为单位，资源管理比MapReduce1.0更高效；</li></ol><p>YARN的目标：</p><p>实现一个集群多个框架（即一个集群上部署一个统一的资源调度框架YARN，在YARN上可以部署其他各种计算框架），如：</p><ul><li>MapReduce实现离线批处理</li><li>Impala实现实时交互式查询分析</li><li>使用Storm实现流式数据实时分析</li><li>使用Spark实现迭代计算</li></ul><p>由YARN为这些计算框架提供统一的资源调度管理服务，并且能够根据各种计算框架的需求，调整各自占用的资源，实现集群资源共享和资源弹性收缩；同时也可以实现一个集群上的不同应用负载混搭，有效提高集群的利用率；不同计算框架可以共享底层存储，避免了数据跨集群移动。</p><h1 id="Pig"><a href="#Pig" class="headerlink" title="Pig"></a>Pig</h1><p>是整个Hadoop生态系统中的一个组件，提供了类似SQL的Pig Latin语言（包含Filter过滤、group By分组 、Join连接、OrderBy分组等操作，同时也支持用户自定义函数）；用户只需要编写简单的Pig Latin语句就可以完成各种复杂的数据分析任务。系统会自动把用户编写的脚本转换成MapReduce作业放在Hadoop集群上运行，而且具备对生成MapReduce程序进行自动优化的功能。</p><ul><li>通过LOAD语句去文件系统加载数据</li><li>通过一系列转换对数据进行处理</li><li>通过STORE语句把处理结果输出到文件当中去，或者用DUMP语句把处理结果输出到屏幕上</li></ul><p>示例：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">&#x2F;&#x2F;处理用户访问网页情况的统计分析visits &#x3D; load&#39;&#x2F;data&#x2F;visits&#39; as (user, url, time);&#x2F;&#x2F;对网页进行分组（根据url）gVisits &#x3D; group visits by url;&#x2F;&#x2F;对每个网页进行同级visitCounts &#x3D; foreach gVisits generate url,count(visits);&#x2F;&#x2F;得到的表的结构 visitCounts(url, visits)urlInfo &#x3D; load&#39;&#x2F;data&#x2F;urlInfo&#39; as (url,category,pRank);visitCounts &#x3D; join visitCounts by url,urlInfo by url;&#x2F;&#x2F;得到的连接结果 表的结构visitCounts(url,visits,category,pRank);gCatagories &#x3D; group visitCounts by category;topUrls &#x3D; foreach gCategories generate top(visitCounts,10);store topUrls into &#39;&#x2F;data&#x2F;topUrls&#39;;</code></pre><p>之后Pig会将代码自动转化成MapReduce任务执行。</p><h1 id="Tez"><a href="#Tez" class="headerlink" title="Tez"></a>Tez</h1><p>Tez是Apache开源的支持DAG作业的计算框架，直接来源于MapReduce框架；核心思想是把Map和Reduce两个操作进一步拆开。</p><h1 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h1><p>由Scala编写成的，</p><p>特点：</p><ul><li>基于内存大数据计算，带来更高的迭代运算效率</li><li>基于DAG的任务调度执行机制，优于MapReduce的迭代执行机制，以支持循环数据流与内存计算</li><li>在借鉴Hadoop MapReduce优点的同时，很好的解决了MapReduce所面临的问题 </li><li>容易使用：支持使用Scala、Java、Python和R语言进行编程；同时还可以通过Spark Shell进行交互式编程</li><li>通用性：提供了完整强大的技术栈，包括SQL查询、流式计算、机器学习和图算法组件</li><li>运行模式多样：可以运行于独立的集群模式中，可以运行在Hadoop中，也可以运行于Amazon EC2等云环境中，并且可以访问HDFS、HBase、Hive等多种数据源</li><li>可同时满足三种企业级应用场景，即同时支持批处理、交互式查询、流数据处理</li></ul><h2 id="RDD特性："><a href="#RDD特性：" class="headerlink" title="RDD特性："></a>RDD特性：</h2><p>RDD（Resilient Distributed Datasets），即弹性分布式数据集</p><p>DAG（Directed Acyclic Graph）即有向无环图</p><p>Spark的核心是建立在统一的抽象RDD之上的。使得Spark的各个组件可以无缝地进行集成，在同一个应用程序中完成大数据计算任务。</p><p>解决的问题：许多迭代式计算任务时，需要反复的重用中间结果，导致了大量的数据复制、磁盘读写等</p><p>概念：一个RDD就是一个分布式对象集合，本质上是一个只读的分区记录集合，，每个RDD可以分成多个分区，每个分区就是一i个数据集片段，并且一个RDD的不同分区可以被保存到集群中不同的节点，从而可以在集群中的不同节点上进行并行计算。RDD提供了一种高度受限的共享内存模型，即RDD是只读的记录分区的集合，不能直接修改，只能基于稳定的物理存储中的数据集来创建RDD。</p><p>RDD提供了一组丰富的操作以支持常见的数据运算，分成”行动“和”转换“两种类型，前者用于执行计算并指定输出的形式，后者指定RDD之间的相互依赖关系。两类操作的主要区别是：转换操作（如map、filter、groupBy、join等）接受RDD并返回RDD，而行动操作（如count、collect等）接受RDD但是返回非RDD，即输出一个值或结果。</p><p>RDD只支持粗粒度的数据转换操作，而不是针对某个数据的细粒度修改。因此RDD比较适用于数据集中元素执行相同操作的批处理应用；而不适用于需要异步、细粒度状态的应用（如web应用程序、增量式的网页爬虫等）。</p><p>RDD转换和行动的系列操作，被称为一个”血缘关系“，即DAG图的拓扑排序的结果。</p><p>Spark采用RDD之后可以实现高效计算的原因：</p><ol><li>高效的容错性：血缘关系、重新计算丢失分区、无需回滚系统、重算过程在不同节点之间并行、只记录粗粒度的操作；</li><li>中间结果持久化到内存，数据在内存中的多个RDD操作之间进行传递，避免了不必要的读写磁盘开销；</li><li>存放的数据可以是Java对象，避免了不必要的对象序列化和反序列化开销。</li></ol><h2 id="RDD之间的依赖关系："><a href="#RDD之间的依赖关系：" class="headerlink" title="RDD之间的依赖关系："></a>RDD之间的依赖关系：</h2><p>窄依赖：一个父RDD对应一个子RDD的分区，或多个父RDD的分区对应于一个子RDD的分区；</p><p>宽依赖：一个父RDD的一个分区对应一个子RDD的多个分区。</p><p>总而言之，父RDD的一个分区只被一个子RDD的一个分区所使用就是窄依赖，否则就是宽依赖。</p><p>窄依赖的典型操作有：map、filter、union等；</p><p>宽依赖的典型操作有：groupByKey、sortByKey等。</p><p>对于Join操作，有两种情况：</p><ol><li>对输入进行协同划分，属于窄依赖，即多个父RDD的某一分区的所有“键”落在子RDD的同一个分区内，不会产生同一个RDD的某一分区落在子RDD的两个分区的情况</li><li>对输入做非协同划分，属于宽依赖。</li></ol><img src="https://raw.githubusercontent.com/Hopefuling/pic_save/master/img/202310012334629.png" alt="image-20231001233433409" style="zoom: 40%;" /><p>Spark通过分析各个RDD的依赖关系生成了DAG，再通过分析各个RDD的分区之间的依赖关系来决定如何划分Stage，具体划分方法：</p><p>在DAG中进行反向解析，遇到宽依赖就断开；遇到窄依赖就把当前的RDD加入到Stage中；将窄依赖尽量划分在同一个Stage中，可以实现流水式计算，从而使得数据可以直接在内存中进行交换，避免了磁盘IO开销。</p><p>整个RDD运行过程：</p><ol><li>创建RDD对象</li><li>SparkContext负责计算RDD之间的依赖关系，构建DAG</li><li>DAGScheduler负责把DAG图分解成多个Stage，每个Stage中包含了多个Task，每个Task会被TaskScheduler分发给各个WorkerNode上的Executor去执行</li></ol><h1 id="Scala"><a href="#Scala" class="headerlink" title="Scala"></a>Scala</h1><p>特性：</p><ul><li>具备强大的并发性，支持函数式编程，可以更好的支持分布式系统</li><li>语法简洁，提供优雅的API</li><li>兼容Java，运行速度快，且能融合到Hadoop生态圈中</li><li>提供了REPL（read-eval-print-loop交互式解释器），提高了程序开发效率</li></ul><h1 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h1><p>特点：</p><ul><li>一种高吞吐量的分布式发布订阅消息系统，用户通过Kafka系统可以发布大量的消息，同时也能实时订阅消费信息</li><li>同时满足在线实时处理和批量离线处理</li><li>作为数据交换枢纽，不同类型的分布式系统可以统一接入到Kafka，实现和Hadoop各个组件之间的不同类型数据的实时高效交换。</li></ul><hr><h1 id="Linux-记录"><a href="#Linux-记录" class="headerlink" title="Linux 记录"></a>Linux 记录</h1><p>查看磁盘分区上可以使用的空间 df<br> 查看每个文件和目录的磁盘使用空间 du </p><p>安装hbase的时候ubuntu系统空间满了 需要扩容一下</p><p><a href="https://blog.csdn.net/toby54king/article/details/105375527">https://blog.csdn.net/toby54king/article/details/105375527</a></p><p>vim下显示行号：在命令模式下 :set nu</p><p>取消行号：在命令模式下 :set nonu</p><p>vim 搜索关键词</p><ol><li>在命令模式(按esc即可)下敲斜杆( &#x2F; )这时在状态栏（也就是屏幕左下脚）就出现了“&#x2F;”</li><li>然后输入你要<strong>查找</strong>的<strong>关键字</strong>敲回车就可以了</li><li>如果你要继续<strong>查找</strong>此<strong>关键字</strong>，敲字符n 就可以继续<strong>查找</strong>了</li><li>敲字符N（大写N）就会向前查询；</li></ol><p>查看历史命令 history </p><p>重新运行历史记录命令  !xx  </p><p>重新执行上一条指令 !!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;弱鸡学大数据&amp;#x3D;_&amp;#x3D;&lt;/p&gt;
&lt;p&gt;视频学习：厦门大学林子雨老师 &lt;a href=&quot;https://www.bilibili.com/video/BV1ds41157NS?p=83&amp;vd_source=b0c1d863140b2d5070f5b01941c</summary>
      
    
    
    
    
    <category term="大数据" scheme="https://hopefuling.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://hopefuling.github.io/2023/09/06/hello-world/"/>
    <id>https://hopefuling.github.io/2023/09/06/hello-world/</id>
    <published>2023-09-06T07:32:59.090Z</published>
    <updated>2023-09-19T10:42:02.753Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
